{"history":[{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"gradient","usesPingPong":false,"speed":0.25,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform vec2 uMousePos;vec3 getColor(int index) { switch(index) { case 0: return vec3(0.08235294117647059, 0.08235294117647059, 0.08235294117647059); case 1: return vec3(0, 0, 0); case 2: return vec3(0, 0, 0); case 3: return vec3(0, 0, 0); case 4: return vec3(0, 0, 0); case 5: return vec3(0, 0, 0); case 6: return vec3(0, 0, 0); case 7: return vec3(0, 0, 0); case 8: return vec3(0, 0, 0); case 9: return vec3(0, 0, 0); case 10: return vec3(0, 0, 0); case 11: return vec3(0, 0, 0); case 12: return vec3(0, 0, 0); case 13: return vec3(0, 0, 0); case 14: return vec3(0, 0, 0); case 15: return vec3(0, 0, 0); default: return vec3(0.0); } }const float PI = 3.14159265;vec2 rotate(vec2 coord, float angle) { float s = sin(angle); float c = cos(angle); return vec2( coord.x * c - coord.y * s, coord.x * s + coord.y * c ); }out vec4 fragColor;vec3 getColor(vec2 uv) {return vec3(0.08235294117647059, 0.08235294117647059, 0.08235294117647059); }void main() {vec2 uv = vTextureCoord; vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000); uv -= pos; uv /= (0.5000*2.); uv = rotate(uv, (0.0000 - 0.5) * 2. * PI); vec4 color = vec4(getColor(uv), 1.); fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"],"data":{"downSample":0.5,"depth":false,"uniforms":{},"isBackground":true},"id":"effect"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"godrays","usesPingPong":false,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"parentLayer":"c4580d8b-e85b-4c37-bb97-09cef606490f","animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;const float MAX_ITERATIONS = 64.; const float PI2 = 6.28318530718; const float EPSILON = 0.0001; const float stepFactor = 0.0098;vec4 getBrightAreas(vec2 uv) { vec4 color = texture(uTexture, uv); float lum = dot(color.rgb, vec3(0.299, 0.587, 0.114)); color = color * smoothstep(0.5000 - 0.1, 0.5000, lum); return color; }vec4 getColor(vec2 uv) { return getBrightAreas(uv); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); if(0 == 2) { fragColor = color;} else { fragColor = color; } }","#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uMousePos;uvec2 pcg2d(uvec2 v) { v = v * 1664525u + 1013904223u; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; v ^= v >> 16; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; return v; }float randFibo(vec2 p) { uvec2 v = floatBitsToUint(p); v = pcg2d(v); uint r = v.x ^ v.y; return float(r) / float(0xffffffffu); }const float MAX_ITERATIONS = 64.; const float PI2 = 6.28318530718; const float EPSILON = 0.0001; const float stepFactor = 0.0098;vec4 godRays(vec2 st, float decay) { vec3 color = vec3(0); float offset = (0.25 + min(1., 0.5000)) * stepFactor; vec2 pos = vec2(0.5, 0.5) - mix(vec2(0), (vec2(1. - uMousePos.x, 1. - uMousePos.y) - 0.5), 0.0000); float weight = 1.0; float bnoz = randFibo(st) * 0.5000; float distanceInfo = 0.0; vec2 marchPos = st;for (float i = 0.0; i < MAX_ITERATIONS; i += 4.0) { for (float j = 0.0; j < 4.0; j++) { float bno = randFibo(st + vec2(i/MAX_ITERATIONS + j/4.0)) * 0.5000; vec2 offbno = vec2(cos(bno) - 0.5, sin(bno) - 0.5); float x = min(0.999, (i + j) * offset) + bnoz * 0.02; float y = min(0.999, (i + j)); marchPos = st * (1.0 - x) + vec2(x * 0.5) + (pos - 0.5) * x + offbno * 0.02 * 0.2500 * x; color += texture(uTexture, marchPos).rgb * weight; distanceInfo += y * weight; weight *= decay; if(weight < 0.01) break; } } return vec4(color / MAX_ITERATIONS, distance(st, marchPos)); }vec4 getGodRays(vec2 uv) { if(0.5000 == 0.) { return vec4(0); } vec4 rays = godRays(uv, 0.972); rays.rgb *= vec3(1, 1, 1); vec4 color; color.rgb = rays.rgb; color.a = rays.a; return color; }vec4 getColor(vec2 uv) { return getGodRays(uv); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); if(1 == 2) { fragColor = color;} else { fragColor = color; } }","#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture; uniform sampler2D uBlueNoise;uniform vec2 uResolution;const float MAX_ITERATIONS = 64.; const float PI2 = 6.28318530718; const float EPSILON = 0.0001; const float stepFactor = 0.0098;float luma(vec4 color) { return dot(color.rgb, vec3(0.299, 0.587, 0.114)); }float getBlueNoiseOffset(vec2 st) { ivec2 texSize = ivec2(512, 512); vec4 blueNoise = texelFetch(uBlueNoise, ivec2(fract(st * (uResolution)/vec2(texSize) * vec2(texSize.x/texSize.y, 1.0)) * vec2(texSize)) % texSize, 0); return mod((blueNoise.r - 0.5) * PI2, PI2); }vec4 composite(vec2 uv) { vec4 godrays = texture(uTexture, uv); float distanceInfo = godrays.a; float luminance = luma(godrays); float blueNoise = getBlueNoiseOffset(uv) - 0.5; vec2 circNoise = vec2(cos(blueNoise), sin(blueNoise)); float brightnessScale = (1. - (luminance + 0.25)); vec2 offset = circNoise * 0.05 * pow(brightnessScale, 3.) * distanceInfo * 2.; vec4 color = texture(uTexture, uv + offset); vec4 bg = texture(uBgTexture, uv);color.rgb = bg.rgb + (color.rgb * 2.9 * 0.5000 + blueNoise * 0.001); color.a = bg.a + color.r; return color; }vec4 getColor(vec2 uv) { return composite(uv); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); if(2 == 2) { fragColor = color;} else { fragColor = color; } }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false,"passes":[{"prop":"pass","value":1,"downSample":0.5},{"prop":"pass","value":2,"includeBg":true}],"texture":{"src":"https://assets.unicorn.studio/media/blue_noise_med.png","sampler":"uBlueNoise"}},"id":"effect1"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"guilloche","usesPingPong":false,"amount":1,"speed":0.25,"texture":false,"parentLayer":"398a8536-9bdf-41f5-b9a3-7224f6cf68e7","animating":true,"mouseMomentum":0,"isMask":0,"states":{"appear":[{"local":{"pendingChanges":{},"changeDebouncer":null,"dragSession":null},"type":"appear","id":"3007a857-b530-45e1-b78e-db47adadcfc7","prop":"amount","transition":{"duration":1000,"delay":1000,"ease":"easeInOutQuart"},"complete":false,"progress":0,"value":1,"endValue":0,"initialized":false,"breakpoints":[],"loop":"none","loopDelay":0,"uniformData":{"type":"1f","name":"uAmount"}}],"scroll":[],"hover":[]},"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uAmount; uniform float uTime;uniform vec2 uResolution;const float PI = 3.14159265359; mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }float getWaveLine(vec2 uv, float intensity) { float lineFreq = 150.0 * 0.5300; float waveAmplitude = 0.04 * 0.5000; float waveFreq = 8.0 * 0.5000; float sineOffset = waveAmplitude * sin((uv.x + uTime*0.005) * waveFreq * 2.0 * 3.14159); uv.y += sineOffset; float lineWidth = mix(0., 1., intensity);float linePosition = fract(uv.y * lineFreq); float gradient = smoothstep(0., lineWidth, linePosition) - smoothstep(1.0 - lineWidth, 1.0, linePosition);return smoothstep(0., lineWidth*1.5, gradient*gradient); }float getZigZagLine(vec2 uv, float lineWidth) { float lineFreq = 150.0 * 0.5300; float waveAmplitude = 0.8 * 0.5000; float flipInterval = 0.2 * (1. - 0.5000 + 0.001); float flip = mod(floor(uv.x / flipInterval), 2.0); uv.x -= flipInterval * 0.5 + floor(uv.x / flipInterval) * flipInterval + uTime*0.005; uv = (uv * rot(waveAmplitude * (flip * 2.0 - 1.0))); uv.x += flipInterval * 0.5;float linePosition = fract(uv.y * lineFreq);float gradient = smoothstep(0.0, lineWidth, linePosition) - smoothstep(1.0 - lineWidth, 1.0, linePosition); return smoothstep(0., lineWidth*1.5, gradient*gradient); }float getGuillocheLine(vec2 uv, float lineWidth) { float lineFreq = 150.0 * 0.5300; float waveAmplitude = 0.04 * 0.5000; float waveFreq = 8.0 * 0.5000; uv.x += waveAmplitude * sin((uv.y + uTime*0.005) * waveFreq * 2.0 * 3.14159);float linePosition = fract(uv.x * lineFreq);float gradient = smoothstep(0.0, lineWidth, linePosition) - smoothstep(1.0 - lineWidth, 1.0, linePosition); return smoothstep(0., 1., gradient*gradient); }float getGuillocheFull(vec2 uv, float lineWidth) { float mult = getGuillocheLine(uv * rot(0.25 * 2. * PI), lineWidth) * 0.75; float add = getGuillocheLine(uv * rot(0.25 * 2. * PI), lineWidth) + getGuillocheLine(uv, lineWidth); return mix(add, mult, smoothstep(0., 1., lineWidth)); }vec3 photoshop_desaturate(vec3 color) { float bw = (min(color.r, min(color.g, color.b)) + max(color.r, max(color.g, color.b))) * 0.5; return vec3(bw); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord;vec4 color = texture(uTexture, uv); vec3 linographed = vec3(0);float red = 1.-color.r; float green = 1.-color.g; float blue = 1.-color.b;vec2 st = rot(0.0000 * -1. * 2. * PI) * ((uv * vec2(uResolution.x/uResolution.y, 1.)) - vec2(0.5, 0.5)); if(0 == 0) { linographed = vec3( getGuillocheFull(st, red), getGuillocheFull(st, green), getGuillocheFull(st, blue) ); } if(0 == 1) { linographed = vec3( getWaveLine(st, red), getWaveLine(st, green), getWaveLine(st, blue) ); } if(0 == 2) { linographed = vec3( getZigZagLine(st, red), getZigZagLine(st, green), getZigZagLine(st, blue) ); }color.rgb = mix(color.rgb, linographed, uAmount); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect2"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"beam","usesPingPong":false,"skew":1,"mix":0,"speed":0.58,"trackMouse":0.01,"trackAxes":"xy","mouseMomentum":0,"texture":false,"parentLayer":"8d16da61-6e41-4fe8-af06-a3c080120797","animating":true,"isMask":0,"states":{"appear":[{"local":{"pendingChanges":{},"changeDebouncer":null,"dragSession":null},"type":"appear","id":"b61b2109-6f8d-4d55-8bc3-49695f344481","prop":"mix","transition":{"ease":"easeInOutQuart","duration":1000,"delay":1500},"complete":false,"progress":0,"value":0,"endValue":1,"initialized":false,"breakpoints":[],"loop":"none","loopDelay":0,"uniformData":{"type":"1f","name":"uMix"}},{"local":{"pendingChanges":{},"changeDebouncer":null,"dragSession":null},"type":"appear","id":"6eef63b4-0b0f-4561-89e0-2ca857f0d4d5","prop":"skew","transition":{"delay":2000,"ease":"easeInOutQuart","duration":500},"complete":false,"progress":0,"value":1,"endValue":0.53,"initialized":false,"breakpoints":[],"loop":"none","loopDelay":0,"uniformData":{"type":"1f","name":"uSkew"}}],"scroll":[],"hover":[]},"compiledFragmentShaders":["#version 300 es\nprecision highp float; precision highp int;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime; uniform float uSkew; uniform float uMix;uniform vec2 uMousePos; uniform vec2 uResolution; vec3 blend (int blendMode, vec3 src, vec3 dst) { return src + dst; }uvec2 pcg2d(uvec2 v) { v = v * 1664525u + 1013904223u; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; v ^= v >> 16; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; return v; }float randFibo(vec2 p) { uvec2 v = floatBitsToUint(p); v = pcg2d(v); uint r = v.x ^ v.y; return float(r) / float(0xffffffffu); }vec3 Tonemap_tanh(vec3 x) { x = clamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }out vec4 fragColor;const float PI = 3.14159265359; const float TWO_PI = 2.0 * PI;float luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }vec3 drawSpiral(vec2 uv, vec2 center, float scale) { uv.x *= uResolution.x/uResolution.y; center.x *= uResolution.x/uResolution.y; vec2 skew = vec2(uSkew, 1. - uSkew) * 2.;uv *= skew; center *= skew;vec3 total = vec3(0);float angle = atan(uv.y, uv.x); float dist = length(uv - center);for(float i = 0.; i < 3.; i++) { float angle = (0.1809 + 0.5) * dist + i/3. - uTime * 0.01; float thickness = 0.5000 * 0.5; vec2 s = vec2(0.5 + thickness, 0.5 - thickness) * 2.; vec2 st = uv * rot(angle * TWO_PI) * s; vec2 c = center * rot(angle * TWO_PI) * s; float dist = distance(st, c); float radius = scale * 0.25;vec3 brightness = (radius / dist) * vec3(0.06274509803921569, 0.7137254901960784, 0.403921568627451);total += brightness * 0.3333; }return total; }vec3 getBeam(vec2 uv) { vec2 pos = vec2(0.5344195888754535, 0.7738935912938332) + mix(vec2(0), (uMousePos-0.5), 0.0100); return drawSpiral(uv, pos, 0.1500); }void main() { vec2 uv = vTextureCoord; vec4 bg = texture(uTexture, uv);vec3 beam = getBeam(uv); float dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0;vec3 blended = blend(1, Tonemap_tanh(beam), bg.rgb); vec3 result = mix(bg.rgb, blended, uMix); result += dither;vec4 color = vec4(result, max(bg.a, luma(beam))); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect3"},{"breakpoints":[],"visible":true,"locked":false,"aspectRatio":0.9895833333333333,"layerName":"","userDownsample":1,"isElement":true,"opacity":1,"effects":["d139944c-f7db-4405-a658-7991ccd77af3","4882a347-f3b1-4b4c-aa60-42d54e84913e","10d5aa27-50ba-41f9-abd9-0818e4a98460","c4580d8b-e85b-4c37-bb97-09cef606490f","398a8536-9bdf-41f5-b9a3-7224f6cf68e7","8d16da61-6e41-4fe8-af06-a3c080120797"],"displace":0,"trackMouse":0.02,"anchorPoint":"center","mouseMomentum":0,"blendMode":"NORMAL","bgDisplace":0,"mask":0,"maskBackground":{"type":"Vec3","_x":0,"_y":0,"_z":0},"maskAlpha":0,"maskDepth":0,"dispersion":0,"axisTilt":0,"states":{"appear":[],"scroll":[],"hover":[]},"layerType":"image","imageLoaded":false,"width":450,"widthMode":"fixed","height":454.7368421052632,"heightMode":"auto","left":0.5,"leftMode":"relative","top":0.3511111111111111,"topMode":"relative","rotation":0,"trackAxes":"xy","fitToCanvas":0,"src":"https://assets.unicorn.studio/images/j4zenaojE3VJilKLb7choDB1YK42/DootLord.png","naturalWidth":760,"naturalHeight":768,"compiledFragmentShaders":["#version 300 es\nprecision highp float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uBgTexture; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform int uSampleBg;out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.0200);uv = uv - pos;vec4 color = texture(uTexture, uv); vec4 background = vec4(0);if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); }color = mix(background, color / max(color.a, 0.0001), color.a * 1.0000);fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision highp float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"uniforms":{}},"id":"image"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"texturize","usesPingPong":false,"amount":0.55,"offsetX":0,"speed":0.79,"texture":false,"parentLayer":"10d5aa27-50ba-41f9-abd9-0818e4a98460","animating":false,"mouseMomentum":0,"isMask":0,"states":{"appear":[{"local":{"pendingChanges":{},"changeDebouncer":null,"dragSession":null},"type":"appear","id":"a2daa4f4-d6c0-464c-811c-ca1c3e5cefc6","prop":"amount","transition":{"duration":2000,"delay":0,"ease":"easeInOutQuart"},"complete":false,"progress":0,"value":0.48,"endValue":1,"initialized":false,"breakpoints":[],"loop":"none","loopDelay":0,"uniformData":{"type":"1f","name":"uAmount"}},{"local":{"pendingChanges":{},"changeDebouncer":null,"dragSession":null},"type":"appear","id":"24013c06-858f-41b3-adfa-0c184272f0b7","prop":"offsetX","transition":{"duration":2000,"delay":0,"ease":"easeInOutQuart"},"complete":false,"progress":0,"value":0.5,"endValue":0,"initialized":false,"breakpoints":[],"loop":"none","loopDelay":0,"uniformData":{"type":"1f","name":"uOffsetX"}}],"scroll":[],"hover":[]},"compiledFragmentShaders":["#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform float uAmount; uniform float uOffsetX; uniform float uTime;uvec2 pcg2d(uvec2 v) { v = v * 1664525u + 1013904223u; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; v ^= v >> 16; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; return v; }float randFibo(vec2 p) { uvec2 v = floatBitsToUint(p); v = pcg2d(v); uint r = v.x ^ v.y; return float(r) / float(0xffffffffu); } out vec4 fragColor;void main() { vec2 uv = vTextureCoord; float timeRand1 = randFibo(vec2(floor(uTime * 0.5) * 2. + 0.001, 0.5)); float timeRand2 = randFibo(vec2(floor(uTime * 0.5) * 2. + 1.001, 0.5)); float sizeX = uAmount * 0.2 * timeRand1; float sizeY = uAmount * 0.2 * timeRand2; float floorY = floor(uv.y/sizeY) + 0.005; float floorX = floor(uv.x/sizeX) + 0.005; float phase = 0.0000 * 0.01; float chromab = 0.5800 * 0.75; float offset = 0.;vec2 blockSize = vec2(50.0, 50.0) * (1.0 - uAmount); vec2 blockUV = floor(uv * blockSize) / blockSize; float blockRand = randFibo(blockUV); float blockTimeRand = timeRand1; float blockNoise = mix( 1., step(0.8, randFibo(vec2(blockTimeRand, blockRand))), 0.5300 );float offsetX = uOffsetX * 0.5 * blockNoise; float offsetY = 0.0000 * 0.5 * blockNoise;float randY = randFibo(vec2(sin(floorY + offset + phase), 0.5)); float randX = randFibo(vec2(cos(floorX + offset + phase), 0.5)); float glitchModX = max(0.005, sign(randY - 0.5 - (1. - 0.6300*2.)/2.)); float glitchModY = max(0.005, sign(randX - 0.5 - (1. - 0.6300*2.)/2.));float randOffX = randFibo(vec2(floorY + offset * glitchModX + phase, 0.7)); float randOffY = randFibo(vec2(floorX + offset * glitchModY + phase, 0.9)); float offX = (randOffX * offsetX - offsetX/2.)/5.; float offY = (randOffY * offsetY - offsetY/2.)/5.;offX = clamp(offX, -1.0, 1.0); offY = clamp(offY, -1.0, 1.0);uv.x = mix(uv.x, uv.x + offX * 2., glitchModX); uv.y = mix(uv.y, uv.y + offY * 2., glitchModY);float waveFreq = 30.0; float waveAmp = 0.005 * 0.2000; float timeOffset = uTime * 0.05; float sinY = sin((uv.y + 0.0000) * waveFreq * (1. - uAmount) * 2. + timeOffset); float rogue = smoothstep(0., 2., sinY - 0.5) * 0.2 * 0.2000; float sinWaveX = sin(uv.y * waveFreq + uTime); float sinWaveY = sin(uv.x * waveFreq + uTime); uv.x += sinWaveX * waveAmp + rogue; uv.y += sinWaveY * waveAmp; float waveX = sinWaveX * waveAmp + rogue * chromab * 0.2;uv = clamp(uv, vec2(0.005), vec2(0.995));vec4 color = texture(uTexture, uv);vec2 redOffset = vec2( clamp(uv.x + (glitchModX * -offX * chromab - waveX), 0.005, 0.995), clamp(uv.y + (glitchModX * -offY * chromab), 0.005, 0.995) ); vec2 blueOffset = vec2( clamp(uv.x + (glitchModX * offX * chromab + waveX), 0.005, 0.995), clamp(uv.y + (glitchModX * offY * chromab), 0.005, 0.995) );color.r = texture(uTexture, redOffset).r; color.b = texture(uTexture, blueOffset).b; fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect4"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"vignette","usesPingPong":false,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float; in vec3 vVertexPosition; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform vec2 uResolution;out vec4 fragColor; mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); } void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); float luma = dot(color.rgb, vec3(0.299, 0.587, 0.114)); float displacement = (luma - 0.5) * 0.0000 * 0.5; vec2 aspectRatio = vec2(uResolution.x/uResolution.y, 1.0); vec2 skew = vec2(0.5000, 1.0 - 0.5000); float halfRadius = 0.5000 * 0.5; float innerEdge = halfRadius - 1.0000 * halfRadius * 0.5; float outerEdge = halfRadius + 1.0000 * halfRadius * 0.5; vec2 pos = vec2(0.5, 0.5); const float TWO_PI = 6.28318530718; vec2 scaledUV = uv * aspectRatio * rot(0.0000 * TWO_PI) * skew; vec2 scaledPos = pos * aspectRatio * rot(0.0000 * TWO_PI) * skew; float radius = distance(scaledUV, scaledPos); float falloff = smoothstep(innerEdge + displacement, outerEdge + displacement, radius); vec3 finalColor;finalColor = mix(color.rgb, mix(color.rgb, vec3(0, 0, 0), 1.0000), falloff); color = mix(color * (1.-falloff), vec4(finalColor * color.a, color.a), 1.0000); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect5"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"reflectiveSurface","usesPingPong":false,"texture":false,"animating":false,"mouseMomentum":0,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uResolution;out vec4 fragColor;const float PI2 = 6.28318530718;vec2 rotatePoint(vec2 point, vec2 center, float angle) { vec2 translated = point - center; float cosAngle = cos(angle); float sinAngle = sin(angle); vec2 rotated = vec2( translated.x * cosAngle - translated.y * sinAngle, translated.x * sinAngle + translated.y * cosAngle ); return rotated + center; }vec2 getRotatedCoord(vec2 coord) { float aspectRatio = uResolution.x / uResolution.y; vec2 correctedCoord = coord; correctedCoord.x *= aspectRatio; vec2 correctedPos = vec2(0.4879081015719468, 0.39721886336154777); correctedPos.x *= aspectRatio; vec2 rotatedCorrected = rotatePoint(correctedCoord, correctedPos, 0.0000 * PI2); vec2 result = rotatedCorrected; result.x /= aspectRatio; return result; }vec2 getInverseRotatedCoord(vec2 coord) { float aspectRatio = uResolution.x / uResolution.y; vec2 correctedCoord = coord; correctedCoord.x *= aspectRatio; vec2 correctedPos = vec2(0.4879081015719468, 0.39721886336154777); correctedPos.x *= aspectRatio; vec2 rotatedCorrected = rotatePoint(correctedCoord, correctedPos, 0.0000 * -1. * PI2); vec2 result = rotatedCorrected; result.x /= aspectRatio; return result; }const int kernelSize = 36;float getGaussianWeight(int index) { switch(index) { case 0: return 0.00094768; case 1: return 0.00151965; case 2: return 0.00237008; case 3: return 0.00359517; case 4: return 0.0053041; case 5: return 0.00761097; case 6: return 0.01062197; case 7: return 0.01441804; case 8: return 0.01903459; case 9: return 0.0244409; case 10: return 0.03052299; case 11: return 0.03707432; case 12: return 0.04379813; case 13: return 0.05032389; case 14: return 0.05623791; case 15: return 0.06112521; case 16: return 0.06461716; case 17: return 0.06643724; case 18: return 0.06643724; case 19: return 0.06461716; case 20: return 0.06112521; case 21: return 0.05623791; case 22: return 0.05032389; case 23: return 0.04379813; case 24: return 0.03707432; case 25: return 0.03052299; case 26: return 0.0244409; case 27: return 0.01903459; case 28: return 0.01441804; case 29: return 0.01062197; case 30: return 0.00761097; case 31: return 0.0053041; case 32: return 0.00359517; case 33: return 0.00237008; case 34: return 0.00151965; case 35: return 0.00094768; default: return 0.0; } }vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0); float weightSum = 0.0;vec2 rotatedUV = getRotatedCoord(uv); vec2 rotatedPos = vec2(0.4879081015719468, 0.39721886336154777); float y = max(0., distance(rotatedUV.y, rotatedPos.y));float radius = 8.;float amount = max(0.25, (0.5000 + 0.1) * radius * y * 4.); float aspectRatio = uResolution.x/uResolution.y;direction.x /= aspectRatio;color += texture(tex, uv) * getGaussianWeight(0); for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount; color += texture(tex, uv + vec2(x/1000.) * direction) * getGaussianWeight(i); } return color; }vec4 blurPass(vec2 uv) { float aspectRatio = uResolution.x / uResolution.y; vec2 direction = vec2(0);if (0 % 2 == 1) { direction = vec2(1,0); direction.x *= (1.-0.5000); } else { direction = vec2(0,1); }vec2 rotatedUV = getRotatedCoord(uv); vec2 rotatedPos = vec2(0.4879081015719468, 0.39721886336154777); rotatedUV = mix(rotatedUV, (rotatedUV + vec2(0., rotatedPos.y)) * vec2(1., 0.5), 0.5000 - 0.5); uv = getInverseRotatedCoord(rotatedUV);return GaussianBlur(uTexture, uv, direction); }vec4 getColor(vec2 uv) { return blurPass(uv); }void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); fragColor = color;}","#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uResolution;out vec4 fragColor;const float PI2 = 6.28318530718;vec2 rotatePoint(vec2 point, vec2 center, float angle) { vec2 translated = point - center; float cosAngle = cos(angle); float sinAngle = sin(angle); vec2 rotated = vec2( translated.x * cosAngle - translated.y * sinAngle, translated.x * sinAngle + translated.y * cosAngle ); return rotated + center; }vec2 getRotatedCoord(vec2 coord) { float aspectRatio = uResolution.x / uResolution.y; vec2 correctedCoord = coord; correctedCoord.x *= aspectRatio; vec2 correctedPos = vec2(0.4879081015719468, 0.39721886336154777); correctedPos.x *= aspectRatio; vec2 rotatedCorrected = rotatePoint(correctedCoord, correctedPos, 0.0000 * PI2); vec2 result = rotatedCorrected; result.x /= aspectRatio; return result; }vec2 getInverseRotatedCoord(vec2 coord) { float aspectRatio = uResolution.x / uResolution.y; vec2 correctedCoord = coord; correctedCoord.x *= aspectRatio; vec2 correctedPos = vec2(0.4879081015719468, 0.39721886336154777); correctedPos.x *= aspectRatio; vec2 rotatedCorrected = rotatePoint(correctedCoord, correctedPos, 0.0000 * -1. * PI2); vec2 result = rotatedCorrected; result.x /= aspectRatio; return result; }const int kernelSize = 36;float getGaussianWeight(int index) { switch(index) { case 0: return 0.00094768; case 1: return 0.00151965; case 2: return 0.00237008; case 3: return 0.00359517; case 4: return 0.0053041; case 5: return 0.00761097; case 6: return 0.01062197; case 7: return 0.01441804; case 8: return 0.01903459; case 9: return 0.0244409; case 10: return 0.03052299; case 11: return 0.03707432; case 12: return 0.04379813; case 13: return 0.05032389; case 14: return 0.05623791; case 15: return 0.06112521; case 16: return 0.06461716; case 17: return 0.06643724; case 18: return 0.06643724; case 19: return 0.06461716; case 20: return 0.06112521; case 21: return 0.05623791; case 22: return 0.05032389; case 23: return 0.04379813; case 24: return 0.03707432; case 25: return 0.03052299; case 26: return 0.0244409; case 27: return 0.01903459; case 28: return 0.01441804; case 29: return 0.01062197; case 30: return 0.00761097; case 31: return 0.0053041; case 32: return 0.00359517; case 33: return 0.00237008; case 34: return 0.00151965; case 35: return 0.00094768; default: return 0.0; } }vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0); float weightSum = 0.0;vec2 rotatedUV = getRotatedCoord(uv); vec2 rotatedPos = vec2(0.4879081015719468, 0.39721886336154777); float y = max(0., distance(rotatedUV.y, rotatedPos.y));float radius = 8.;float amount = max(0.25, (0.5000 + 0.1) * radius * y * 4.); float aspectRatio = uResolution.x/uResolution.y;direction.x /= aspectRatio;color += texture(tex, uv) * getGaussianWeight(0); for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount; color += texture(tex, uv + vec2(x/1000.) * direction) * getGaussianWeight(i); } return color; }vec4 blurPass(vec2 uv) { float aspectRatio = uResolution.x / uResolution.y; vec2 direction = vec2(0);if (1 % 2 == 1) { direction = vec2(1,0); direction.x *= (1.-0.5000); } else { direction = vec2(0,1); }vec2 rotatedUV = getRotatedCoord(uv); vec2 rotatedPos = vec2(0.4879081015719468, 0.39721886336154777); rotatedUV = mix(rotatedUV, (rotatedUV + vec2(0., rotatedPos.y)) * vec2(1., 0.5), 0.5000 - 0.5); uv = getInverseRotatedCoord(rotatedUV);return GaussianBlur(uTexture, uv, direction); }vec4 getColor(vec2 uv) { return blurPass(uv); }void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); fragColor = color;}","#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture;uniform vec2 uResolution;uvec2 pcg2d(uvec2 v) { v = v * 1664525u + 1013904223u; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; v ^= v >> 16; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; return v; }float randFibo(vec2 p) { uvec2 v = floatBitsToUint(p); v = pcg2d(v); uint r = v.x ^ v.y; return float(r) / float(0xffffffffu); }out vec4 fragColor;const float PI2 = 6.28318530718;vec2 rotatePoint(vec2 point, vec2 center, float angle) { vec2 translated = point - center; float cosAngle = cos(angle); float sinAngle = sin(angle); vec2 rotated = vec2( translated.x * cosAngle - translated.y * sinAngle, translated.x * sinAngle + translated.y * cosAngle ); return rotated + center; }vec2 getRotatedCoord(vec2 coord) { float aspectRatio = uResolution.x / uResolution.y; vec2 correctedCoord = coord; correctedCoord.x *= aspectRatio; vec2 correctedPos = vec2(0.4879081015719468, 0.39721886336154777); correctedPos.x *= aspectRatio; vec2 rotatedCorrected = rotatePoint(correctedCoord, correctedPos, 0.0000 * PI2); vec2 result = rotatedCorrected; result.x /= aspectRatio; return result; }vec2 getInverseRotatedCoord(vec2 coord) { float aspectRatio = uResolution.x / uResolution.y; vec2 correctedCoord = coord; correctedCoord.x *= aspectRatio; vec2 correctedPos = vec2(0.4879081015719468, 0.39721886336154777); correctedPos.x *= aspectRatio; vec2 rotatedCorrected = rotatePoint(correctedCoord, correctedPos, 0.0000 * -1. * PI2); vec2 result = rotatedCorrected; result.x /= aspectRatio; return result; }const int kernelSize = 36;float getGaussianWeight(int index) { switch(index) { case 0: return 0.00094768; case 1: return 0.00151965; case 2: return 0.00237008; case 3: return 0.00359517; case 4: return 0.0053041; case 5: return 0.00761097; case 6: return 0.01062197; case 7: return 0.01441804; case 8: return 0.01903459; case 9: return 0.0244409; case 10: return 0.03052299; case 11: return 0.03707432; case 12: return 0.04379813; case 13: return 0.05032389; case 14: return 0.05623791; case 15: return 0.06112521; case 16: return 0.06461716; case 17: return 0.06643724; case 18: return 0.06643724; case 19: return 0.06461716; case 20: return 0.06112521; case 21: return 0.05623791; case 22: return 0.05032389; case 23: return 0.04379813; case 24: return 0.03707432; case 25: return 0.03052299; case 26: return 0.0244409; case 27: return 0.01903459; case 28: return 0.01441804; case 29: return 0.01062197; case 30: return 0.00761097; case 31: return 0.0053041; case 32: return 0.00359517; case 33: return 0.00237008; case 34: return 0.00151965; case 35: return 0.00094768; default: return 0.0; } }vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0); float weightSum = 0.0;vec2 rotatedUV = getRotatedCoord(uv); vec2 rotatedPos = vec2(0.4879081015719468, 0.39721886336154777); float y = max(0., distance(rotatedUV.y, rotatedPos.y));float radius = 8.;float amount = max(0.25, (0.5000 + 0.1) * radius * y * 4.); float aspectRatio = uResolution.x/uResolution.y;direction.x /= aspectRatio;color += texture(tex, uv) * getGaussianWeight(0); for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount; color += texture(tex, uv + vec2(x/1000.) * direction) * getGaussianWeight(i); } return color; }vec4 blurPass(vec2 uv) { float aspectRatio = uResolution.x / uResolution.y; vec2 direction = vec2(0);if (2 % 2 == 1) { direction = vec2(1,0); direction.x *= (1.-0.5000); } else { direction = vec2(0,1); }vec2 rotatedUV = getRotatedCoord(uv); vec2 rotatedPos = vec2(0.4879081015719468, 0.39721886336154777); rotatedUV = mix(rotatedUV, (rotatedUV + vec2(0., rotatedPos.y)) * vec2(1., 0.5), 0.5000 - 0.5); uv = getInverseRotatedCoord(rotatedUV);return GaussianBlur(uTexture, uv, direction); }vec4 reflectAndMix(vec4 originalColor, vec4 blurredColor, float yPos) { vec2 rotatedCoord = getRotatedCoord(vTextureCoord); float reflectedY = yPos - (rotatedCoord.y - yPos); reflectedY = clamp(reflectedY, 0., 1.);vec2 rotatedReflectedCoord = vec2(rotatedCoord.x, reflectedY); vec2 reflectedCoord = getInverseRotatedCoord(rotatedReflectedCoord); reflectedCoord = clamp(reflectedCoord, 0., 1.);vec4 reflectedColor = texture(uTexture, reflectedCoord);reflectedColor.rgb = mix(vec3(0, 0, 0), reflectedColor.rgb, 0.5000);float dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0; reflectedColor.rgb += dither;return mix(originalColor, reflectedColor, step(rotatedCoord.y, yPos)); }vec4 compositePass(vec2 uv) { vec4 bg = texture(uBgTexture, uv); vec4 blur = blurPass(uv); return reflectAndMix(bg, blur, vec2(0.4879081015719468, 0.39721886336154777).y); }vec4 getColor(vec2 uv) { return compositePass(uv); }void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"downSample":0.25,"depth":false,"uniforms":{},"isBackground":false,"passes":[{"prop":"pass","value":1,"downSample":0.25},{"prop":"pass","value":2,"includeBg":0.5}]},"id":"effect6"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"stretch","usesPingPong":false,"amount":0,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"parentLayer":"d139944c-f7db-4405-a658-7991ccd77af3","animating":false,"isMask":0,"states":{"appear":[{"local":{"pendingChanges":{},"changeDebouncer":null,"dragSession":null},"type":"appear","id":"c6e165df-d2d6-4f85-a212-0a5284bf9a40","prop":"amount","transition":{"duration":1000,"delay":0,"ease":"easeInOutQuart"},"complete":false,"progress":0,"value":1,"endValue":0,"initialized":false,"breakpoints":[],"loop":"none","loopDelay":0,"uniformData":{"type":"1f","name":"uAmount"}}],"scroll":[],"hover":[]},"compiledFragmentShaders":["#version 300 es\nprecision mediump float; in vec3 vVertexPosition; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform float uAmount; uniform vec2 uMousePos; uniform vec2 uResolution;out vec4 fragColor;vec2 rotate(vec2 v, float angle) { float c = cos(angle); float s = sin(angle); return vec2(v.x * c - v.y * s, v.x * s + v.y * c); }vec3 chromatic_aberration(vec3 color, vec2 uv, float amount) { vec2 offset = normalize(vTextureCoord - 0.5) * amount / vec2(uResolution.x/uResolution.y, 1); vec4 left = texture(uTexture, uv - offset); vec4 right = texture(uTexture, uv + offset);color.r = left.r; color.b = right.b;return color; }void main() { vec2 uv = vTextureCoord; float angle = (0.5000 - 0.25) * -6.28318530718; float stretchX = vec2(1, 1).x * 4. * uAmount; float stretchY = vec2(1, 1).y * 4. * uAmount;vec2 pos = vec2(0.5, 1.27) + (uMousePos - 0.5) * 0.0000; vec2 offset = uv - pos; vec2 rotatedOffset = rotate(offset, -angle); vec2 stretchedOffset = rotatedOffset; if (2 == 1) { if (rotatedOffset.x > 0.0) { float stretchIntensity = rotatedOffset.x; stretchedOffset.x = rotatedOffset.x / (1.0 + stretchX * stretchIntensity); stretchedOffset.y = rotatedOffset.y / (1.0 + stretchY * stretchIntensity * stretchIntensity); } } else if (2 == 2) { float stretchIntensity = abs(rotatedOffset.x); stretchedOffset.x = sign(rotatedOffset.x) * stretchIntensity / (1.0 + stretchX * stretchIntensity); stretchedOffset.y = rotatedOffset.y / (1.0 + stretchY * stretchIntensity * stretchIntensity); } vec2 finalOffset = rotate(stretchedOffset, angle); vec2 st = pos + finalOffset; vec4 color = texture(uTexture, st);color.rgb = chromatic_aberration(color.rgb, st, length(st - uv) * 0.05 * 1.0000); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect7"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"mouse","usesPingPong":true,"mouseMomentum":0,"texture":false,"parentLayer":"4882a347-f3b1-4b4c-aa60-42d54e84913e","animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uTexture; uniform sampler2D uPingPongTexture; uniform vec2 uResolution;const float PI = 3.1415926; const float ITERATIONS = 24.0;out vec4 fragColor;vec3 rgb2hsv(vec3 c) { vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0); vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g)); vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));float d = q.x - min(q.w, q.y); float e = 1.0e-10; return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x); }vec3 chromatic_aberration(vec3 color, vec2 uv, vec2 offset) { vec4 left = texture(uTexture, uv - offset); vec4 right = texture(uTexture, uv + offset);color.r = left.r; color.b = right.b;return color; }vec2 angleToDir(float angle) { float rad = angle * 2.0 * PI; return vec2(cos(rad), sin(rad)); }vec4 defaultTrail(vec2 uv, vec2 mouseDir) { vec4 color = vec4(0); vec2 distorted = mouseDir * 0.4; uv -= distorted; color = texture(uTexture, uv); color.rgb = chromatic_aberration(color.rgb, uv, distorted * 1.0000 * 0.12); return color; }vec4 getTrailColor(vec2 uv, vec2 mouseDir, float strength, float aspectRatio) { vec4 color = vec4(0);return defaultTrail(uv, mouseDir); }void main() { vec2 uv = vTextureCoord; vec2 pingpongUv = uv; float aspectRatio = uResolution.x / uResolution.y;vec3 mouseRgb = texture(uPingPongTexture, pingpongUv).rgb; vec3 mouseTrail = rgb2hsv(mouseRgb);float angle = mouseTrail.x; float strength = mouseTrail.z * (0.2900 * 2.0); vec2 direction = angleToDir(angle); vec2 mouseDir = direction * strength;vec4 color = getTrailColor(uv, mouseDir, abs(strength), aspectRatio);fragColor = color; }","#version 300 es\nprecision highp float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uPingPongTexture; uniform vec2 uPreviousMousePos; uniform float uTime;uniform vec2 uMousePos; uniform vec2 uResolution;const float PI = 3.1415926; const float TWOPI = 6.2831852;out vec4 fragColor;vec3 hsv2rgb(vec3 c) { vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0); vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www); return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y); }mat2 rot(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }vec2 liquify(vec2 st, float angle) { float aspectRatio = uResolution.x / uResolution.y; st.x *= aspectRatio; st = st * rot(angle * TWOPI); float amplitude = 0.003; for (float i = 1.0; i <= 5.0; i++) { st = st * rot(i / 5.0 * PI * 2.0); st += vec2( amplitude * cos(i * 5.0 * st.y + uTime * 0.02), amplitude * sin(i * 5.0 * st.x + uTime * 0.02) ); } st = st * rot(-angle * TWOPI); st.x /= aspectRatio; return st; }void main() { float aspectRatio = uResolution.x / uResolution.y; vec2 aspectVec = vec2(aspectRatio, 1.0); vec2 uv = vTextureCoord; vec2 correctedUv = uv * aspectVec;vec2 dir = (uMousePos - uPreviousMousePos) * aspectVec; float dist = length(dir); if (dist > 0.0) { dir = dir / dist; } else { dir = vec2(1.0, 0.0); }float rad = 0.2200 * 0.4 * mix(aspectRatio, 1.0, 0.5); float angle = atan(dir.y, dir.x); if (angle < 0.0) angle += TWOPI;uv = mix(uv, liquify(uv, smoothstep(0.0, 1.0, angle)), 1.0000);float t = dist > 0.0 ? clamp(dot(correctedUv - uPreviousMousePos * aspectVec, dir) / dist, 0.0, 1.0) : 0.0; vec2 closestPoint = mix(uPreviousMousePos, uMousePos, t) * aspectVec; float distanceToLine = distance(correctedUv, closestPoint);float s = smoothstep(rad, rad * 0.0000, distanceToLine);s = s * s;vec3 color = vec3(angle / TWOPI, 1.0, 1.0); vec3 mouseColor = hsv2rgb(color);vec2 sampleUv = mix(uv, uv / (1.0 + 1.0000 * 0.03) + 1.0000 * 0.015, 1.0000); vec3 lastFrameColor = texture(uPingPongTexture, sampleUv).rgb; lastFrameColor = pow(lastFrameColor, vec3(2.2)); mouseColor = pow(mouseColor, vec3(2.2)); float intensity = min(0.7, dist * 10.0) * s * 0.4; vec3 draw = mix(lastFrameColor, mouseColor, intensity); draw *= pow(0.4600, 0.2); draw = pow(draw, vec3(1.0/2.2)); fragColor = vec4(draw, 1.0); }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }","#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect8"},{"breakpoints":[],"visible":true,"locked":false,"aspectRatio":1,"layerName":"DootLord","userDownsample":1,"isElement":true,"opacity":0,"effects":["b0d6a7c0-0f59-4363-a0ef-823521b70d4b","a8a28893-34c3-4d7f-940f-69a1cd8a81d6","0de16c7f-fc28-4d08-a2b9-549ac7db0e13","cf58334b-7b55-4307-a9a3-3c08257498f7","b7552748-e750-4446-9fa5-ab54d4a580f5"],"displace":0,"trackMouse":0.01,"anchorPoint":"center","mouseMomentum":0.5,"blendMode":"NORMAL","bgDisplace":1,"mask":0,"maskBackground":{"type":"Vec3","_x":0,"_y":0,"_z":0},"maskAlpha":0,"maskDepth":0,"dispersion":0,"axisTilt":0,"states":{"appear":[{"local":{"pendingChanges":{},"changeDebouncer":null,"dragSession":null},"type":"appear","id":"c78a3158-4e67-473d-9f17-784d78497fe5","prop":"opacity","transition":{"ease":"easeInOutQuart","duration":1000,"delay":500},"complete":false,"progress":0,"value":0,"endValue":1,"initialized":false,"breakpoints":[],"loop":"none","loopDelay":0,"uniformData":{"type":"1f","name":"uOpacity"}},{"local":{"pendingChanges":{},"changeDebouncer":null,"dragSession":null},"type":"appear","id":"15f669ff-e334-4967-972f-36f6672f83be","prop":"letterSpacing","transition":{"ease":"easeInOutQuart","duration":2000,"delay":500},"complete":false,"progress":0,"value":0,"endValue":15,"initialized":false,"breakpoints":[],"loop":"none","loopDelay":0}],"scroll":[],"hover":[]},"layerType":"text","justCreated":false,"isSafari":false,"width":800,"widthMode":"fixed","height":60,"heightMode":"fixed","left":0.5,"leftMode":"relative","top":0.693,"topMode":"relative","rotation":0,"trackAxes":"xy","fontSize":99,"lineHeight":60,"letterSpacing":0,"fontFamily":"Inria Serif","fontStyle":"regular","fontWeight":"400","textAlign":"center","textContent":"DootLord","fill":["#CEFFDD"],"gradientAngle":0,"gradientType":"linear","fontSizeMode":"fixed","fontCSS":{"family":"Inria Serif","src":"https://assets.unicorn.studio/fonts/google_fonts/fC1lPYxPY3rXxEndZJAzN0SsfSzNr0Ck.ttf"},"compiledFragmentShaders":["#version 300 es\nprecision highp float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uBgTexture; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform float uOpacity; uniform int uSampleBg;out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.0100);uv = uv - pos;vec4 color = texture(uTexture, uv); vec4 background = vec4(0);if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); }color = mix(background, color / max(color.a, 0.0001), color.a * uOpacity);fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision highp float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"uniforms":{}},"id":"text","windowWidth":1440},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"godrays","usesPingPong":false,"trackMouse":0.11,"trackAxes":"xy","mouseMomentum":0,"texture":false,"parentLayer":"b0d6a7c0-0f59-4363-a0ef-823521b70d4b","animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;const float MAX_ITERATIONS = 64.; const float PI2 = 6.28318530718; const float EPSILON = 0.0001; const float stepFactor = 0.0098;vec4 getBrightAreas(vec2 uv) { vec4 color = texture(uTexture, uv); float lum = dot(color.rgb, vec3(0.299, 0.587, 0.114)); color = color * smoothstep(0.7500 - 0.1, 0.7500, lum); return color; }vec4 getColor(vec2 uv) { return getBrightAreas(uv); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); if(0 == 2) { fragColor = color;} else { fragColor = color; } }","#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uMousePos;uvec2 pcg2d(uvec2 v) { v = v * 1664525u + 1013904223u; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; v ^= v >> 16; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; return v; }float randFibo(vec2 p) { uvec2 v = floatBitsToUint(p); v = pcg2d(v); uint r = v.x ^ v.y; return float(r) / float(0xffffffffu); }const float MAX_ITERATIONS = 64.; const float PI2 = 6.28318530718; const float EPSILON = 0.0001; const float stepFactor = 0.0098;vec4 godRays(vec2 st, float decay) { vec3 color = vec3(0); float offset = (0.25 + min(1., 0.6500)) * stepFactor; vec2 pos = vec2(0.5, 0.5) - mix(vec2(0), (vec2(1. - uMousePos.x, 1. - uMousePos.y) - 0.5), 0.1100); float weight = 1.0; float bnoz = randFibo(st) * 0.6500; float distanceInfo = 0.0; vec2 marchPos = st;for (float i = 0.0; i < MAX_ITERATIONS; i += 4.0) { for (float j = 0.0; j < 4.0; j++) { float bno = randFibo(st + vec2(i/MAX_ITERATIONS + j/4.0)) * 0.6500; vec2 offbno = vec2(cos(bno) - 0.5, sin(bno) - 0.5); float x = min(0.999, (i + j) * offset) + bnoz * 0.02; float y = min(0.999, (i + j)); marchPos = st * (1.0 - x) + vec2(x * 0.5) + (pos - 0.5) * x + offbno * 0.02 * 0.4000 * x; color += texture(uTexture, marchPos).rgb * weight; distanceInfo += y * weight; weight *= decay; if(weight < 0.01) break; } } return vec4(color / MAX_ITERATIONS, distance(st, marchPos)); }vec4 getGodRays(vec2 uv) { if(0.9600 == 0.) { return vec4(0); } vec4 rays = godRays(uv, 0.972); rays.rgb *= vec3(0, 0.9803921568627451, 0.9333333333333333); vec4 color; color.rgb = rays.rgb; color.a = rays.a; return color; }vec4 getColor(vec2 uv) { return getGodRays(uv); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); if(1 == 2) { fragColor = color;} else { fragColor = color; } }","#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture; uniform sampler2D uBlueNoise;uniform vec2 uResolution;const float MAX_ITERATIONS = 64.; const float PI2 = 6.28318530718; const float EPSILON = 0.0001; const float stepFactor = 0.0098;float luma(vec4 color) { return dot(color.rgb, vec3(0.299, 0.587, 0.114)); }float getBlueNoiseOffset(vec2 st) { ivec2 texSize = ivec2(512, 512); vec4 blueNoise = texelFetch(uBlueNoise, ivec2(fract(st * (uResolution)/vec2(texSize) * vec2(texSize.x/texSize.y, 1.0)) * vec2(texSize)) % texSize, 0); return mod((blueNoise.r - 0.5) * PI2, PI2); }vec4 composite(vec2 uv) { vec4 godrays = texture(uTexture, uv); float distanceInfo = godrays.a; float luminance = luma(godrays); float blueNoise = getBlueNoiseOffset(uv) - 0.5; vec2 circNoise = vec2(cos(blueNoise), sin(blueNoise)); float brightnessScale = (1. - (luminance + 0.25)); vec2 offset = circNoise * 0.05 * pow(brightnessScale, 3.) * distanceInfo * 2.; vec4 color = texture(uTexture, uv + offset); vec4 bg = texture(uBgTexture, uv);color.rgb = bg.rgb + (color.rgb * 2.9 * 0.9600 + blueNoise * 0.001); color.a = bg.a + color.r; return color; }vec4 getColor(vec2 uv) { return composite(uv); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); if(2 == 2) { fragColor = color;} else { fragColor = color; } }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false,"passes":[{"prop":"pass","value":1,"downSample":0.5},{"prop":"pass","value":2,"includeBg":true}],"texture":{"src":"https://assets.unicorn.studio/media/blue_noise_med.png","sampler":"uBlueNoise"}},"id":"effect9"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"guilloche","usesPingPong":false,"speed":0.25,"texture":false,"parentLayer":"a8a28893-34c3-4d7f-940f-69a1cd8a81d6","animating":true,"mouseMomentum":0,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime;uniform vec2 uResolution;const float PI = 3.14159265359; mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }float getWaveLine(vec2 uv, float intensity) { float lineFreq = 150.0 * 0.7500; float waveAmplitude = 0.04 * 0.5000; float waveFreq = 8.0 * 0.5000; float sineOffset = waveAmplitude * sin((uv.x + uTime*0.005) * waveFreq * 2.0 * 3.14159); uv.y += sineOffset; float lineWidth = mix(0., 1., intensity);float linePosition = fract(uv.y * lineFreq); float gradient = smoothstep(0., lineWidth, linePosition) - smoothstep(1.0 - lineWidth, 1.0, linePosition);return smoothstep(0., lineWidth*1.5, gradient*gradient); }float getZigZagLine(vec2 uv, float lineWidth) { float lineFreq = 150.0 * 0.7500; float waveAmplitude = 0.8 * 0.5000; float flipInterval = 0.2 * (1. - 0.5000 + 0.001); float flip = mod(floor(uv.x / flipInterval), 2.0); uv.x -= flipInterval * 0.5 + floor(uv.x / flipInterval) * flipInterval + uTime*0.005; uv = (uv * rot(waveAmplitude * (flip * 2.0 - 1.0))); uv.x += flipInterval * 0.5;float linePosition = fract(uv.y * lineFreq);float gradient = smoothstep(0.0, lineWidth, linePosition) - smoothstep(1.0 - lineWidth, 1.0, linePosition); return smoothstep(0., lineWidth*1.5, gradient*gradient); }float getGuillocheLine(vec2 uv, float lineWidth) { float lineFreq = 150.0 * 0.7500; float waveAmplitude = 0.04 * 0.5000; float waveFreq = 8.0 * 0.5000; uv.x += waveAmplitude * sin((uv.y + uTime*0.005) * waveFreq * 2.0 * 3.14159);float linePosition = fract(uv.x * lineFreq);float gradient = smoothstep(0.0, lineWidth, linePosition) - smoothstep(1.0 - lineWidth, 1.0, linePosition); return smoothstep(0., 1., gradient*gradient); }float getGuillocheFull(vec2 uv, float lineWidth) { float mult = getGuillocheLine(uv * rot(0.25 * 2. * PI), lineWidth) * 0.75; float add = getGuillocheLine(uv * rot(0.25 * 2. * PI), lineWidth) + getGuillocheLine(uv, lineWidth); return mix(add, mult, smoothstep(0., 1., lineWidth)); }vec3 photoshop_desaturate(vec3 color) { float bw = (min(color.r, min(color.g, color.b)) + max(color.r, max(color.g, color.b))) * 0.5; return vec3(bw); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord;vec4 color = texture(uTexture, uv); vec3 linographed = vec3(0);float red = 1.-color.r; float green = 1.-color.g; float blue = 1.-color.b;vec2 st = rot(0.0000 * -1. * 2. * PI) * ((uv * vec2(uResolution.x/uResolution.y, 1.)) - vec2(0.5, 0.5)); if(0 == 0) { linographed = vec3( getGuillocheFull(st, red), getGuillocheFull(st, green), getGuillocheFull(st, blue) ); } if(0 == 1) { linographed = vec3( getWaveLine(st, red), getWaveLine(st, green), getWaveLine(st, blue) ); } if(0 == 2) { linographed = vec3( getZigZagLine(st, red), getZigZagLine(st, green), getZigZagLine(st, blue) ); }color.rgb = mix(color.rgb, linographed, 1.0000); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect10"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"godrays","usesPingPong":false,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"parentLayer":"0de16c7f-fc28-4d08-a2b9-549ac7db0e13","animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;const float MAX_ITERATIONS = 64.; const float PI2 = 6.28318530718; const float EPSILON = 0.0001; const float stepFactor = 0.0098;vec4 getBrightAreas(vec2 uv) { vec4 color = texture(uTexture, uv); float lum = dot(color.rgb, vec3(0.299, 0.587, 0.114)); color = color * smoothstep(0.5000 - 0.1, 0.5000, lum); return color; }vec4 getColor(vec2 uv) { return getBrightAreas(uv); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); if(0 == 2) { fragColor = color;} else { fragColor = color; } }","#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uMousePos;uvec2 pcg2d(uvec2 v) { v = v * 1664525u + 1013904223u; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; v ^= v >> 16; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; return v; }float randFibo(vec2 p) { uvec2 v = floatBitsToUint(p); v = pcg2d(v); uint r = v.x ^ v.y; return float(r) / float(0xffffffffu); }const float MAX_ITERATIONS = 64.; const float PI2 = 6.28318530718; const float EPSILON = 0.0001; const float stepFactor = 0.0098;vec4 godRays(vec2 st, float decay) { vec3 color = vec3(0); float offset = (0.25 + min(1., 0.5000)) * stepFactor; vec2 pos = vec2(0.5, 0.5) - mix(vec2(0), (vec2(1. - uMousePos.x, 1. - uMousePos.y) - 0.5), 0.0000); float weight = 1.0; float bnoz = randFibo(st) * 0.5000; float distanceInfo = 0.0; vec2 marchPos = st;for (float i = 0.0; i < MAX_ITERATIONS; i += 4.0) { for (float j = 0.0; j < 4.0; j++) { float bno = randFibo(st + vec2(i/MAX_ITERATIONS + j/4.0)) * 0.5000; vec2 offbno = vec2(cos(bno) - 0.5, sin(bno) - 0.5); float x = min(0.999, (i + j) * offset) + bnoz * 0.02; float y = min(0.999, (i + j)); marchPos = st * (1.0 - x) + vec2(x * 0.5) + (pos - 0.5) * x + offbno * 0.02 * 0.2500 * x; color += texture(uTexture, marchPos).rgb * weight; distanceInfo += y * weight; weight *= decay; if(weight < 0.01) break; } } return vec4(color / MAX_ITERATIONS, distance(st, marchPos)); }vec4 getGodRays(vec2 uv) { if(0.5000 == 0.) { return vec4(0); } vec4 rays = godRays(uv, 0.972); rays.rgb *= vec3(1, 1, 1); vec4 color; color.rgb = rays.rgb; color.a = rays.a; return color; }vec4 getColor(vec2 uv) { return getGodRays(uv); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); if(1 == 2) { fragColor = color;} else { fragColor = color; } }","#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture; uniform sampler2D uBlueNoise;uniform vec2 uResolution;const float MAX_ITERATIONS = 64.; const float PI2 = 6.28318530718; const float EPSILON = 0.0001; const float stepFactor = 0.0098;float luma(vec4 color) { return dot(color.rgb, vec3(0.299, 0.587, 0.114)); }float getBlueNoiseOffset(vec2 st) { ivec2 texSize = ivec2(512, 512); vec4 blueNoise = texelFetch(uBlueNoise, ivec2(fract(st * (uResolution)/vec2(texSize) * vec2(texSize.x/texSize.y, 1.0)) * vec2(texSize)) % texSize, 0); return mod((blueNoise.r - 0.5) * PI2, PI2); }vec4 composite(vec2 uv) { vec4 godrays = texture(uTexture, uv); float distanceInfo = godrays.a; float luminance = luma(godrays); float blueNoise = getBlueNoiseOffset(uv) - 0.5; vec2 circNoise = vec2(cos(blueNoise), sin(blueNoise)); float brightnessScale = (1. - (luminance + 0.25)); vec2 offset = circNoise * 0.05 * pow(brightnessScale, 3.) * distanceInfo * 2.; vec4 color = texture(uTexture, uv + offset); vec4 bg = texture(uBgTexture, uv);color.rgb = bg.rgb + (color.rgb * 2.9 * 0.5000 + blueNoise * 0.001); color.a = bg.a + color.r; return color; }vec4 getColor(vec2 uv) { return composite(uv); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); if(2 == 2) { fragColor = color;} else { fragColor = color; } }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false,"passes":[{"prop":"pass","value":1,"downSample":0.5},{"prop":"pass","value":2,"includeBg":true}],"texture":{"src":"https://assets.unicorn.studio/media/blue_noise_med.png","sampler":"uBlueNoise"}},"id":"effect11"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"bloom","usesPingPong":false,"texture":false,"parentLayer":"cf58334b-7b55-4307-a9a3-3c08257498f7","animating":false,"mouseMomentum":0,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;out vec4 fragColor;float luma(vec4 color) { return dot(color.rgb, vec3(0.299, 0.587, 0.114)); }vec4 thresholdPass(vec4 color) { color.rgb = pow(color.rgb, vec3(1.0/2.2)); color.rgb = 1.2 * (color.rgb - 0.5) + 0.5; vec4 bloom = color * smoothstep(0.8200 - 0.1, 0.8200, luma(color)); return vec4(bloom.rgb, color.a); }vec4 getColor(vec4 color) { return thresholdPass(color); }void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); fragColor = getColor(color); }","#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uResolution;out vec4 fragColor;float getExponentialWeight(int index) { switch(index) { case 0: return 1.0000000000; case 1: return 0.7165313106; case 2: return 0.5134171190; case 3: return 0.3678794412; case 4: return 0.2636050919; case 5: return 0.1888756057; case 6: return 0.1353352832; case 7: return 0.0969670595; case 8: return 0.0694877157; default: return 0.0; } }vec4 blur(vec2 uv, bool vertical, float radius, bool diamond) { vec4 color = vec4(0.0); float total_weight = 0.0; float aspectRatio = uResolution.x/uResolution.y;vec2 dir; if (diamond) { dir = vertical ? vec2(1, 1) : vec2(1, -1); } else { dir = vertical ? vec2(0, 1) : vec2(1, 0); } dir *= vec2(0.0000, 1. - 0.0000); dir.x /= aspectRatio; vec4 center = texture(uTexture, uv); float center_weight = getExponentialWeight(0); color += center * center_weight; total_weight += center_weight;radius *= 0.0100; for (int i = 1; i <= 8; i++) { float weight = getExponentialWeight(i); float offset = mix(0.015, 0.025, radius) * float(i)/8.; vec4 sample1 = texture(uTexture, uv + offset * dir); vec4 sample2 = texture(uTexture, uv - offset * dir); color += (sample1 + sample2) * weight; total_weight += 2.0 * weight; }return color / total_weight; }vec4 blurPass(vec2 uv, bool vertical, float radius, float intensity, bool diamond) { return blur(uv, vertical, radius, diamond); }vec4 getColor(vec4 color) { return blurPass(vTextureCoord, false, 40., 1.25, true); }void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); fragColor = getColor(color); }","#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture;uniform vec2 uResolution;out vec4 fragColor;float luma(vec4 color) { return dot(color.rgb, vec3(0.299, 0.587, 0.114)); }float getExponentialWeight(int index) { switch(index) { case 0: return 1.0000000000; case 1: return 0.7165313106; case 2: return 0.5134171190; case 3: return 0.3678794412; case 4: return 0.2636050919; case 5: return 0.1888756057; case 6: return 0.1353352832; case 7: return 0.0969670595; case 8: return 0.0694877157; default: return 0.0; } }vec4 blur(vec2 uv, bool vertical, float radius, bool diamond) { vec4 color = vec4(0.0); float total_weight = 0.0; float aspectRatio = uResolution.x/uResolution.y;vec2 dir; if (diamond) { dir = vertical ? vec2(1, 1) : vec2(1, -1); } else { dir = vertical ? vec2(0, 1) : vec2(1, 0); } dir *= vec2(0.0000, 1. - 0.0000); dir.x /= aspectRatio; vec4 center = texture(uTexture, uv); float center_weight = getExponentialWeight(0); color += center * center_weight; total_weight += center_weight;radius *= 0.0100; for (int i = 1; i <= 8; i++) { float weight = getExponentialWeight(i); float offset = mix(0.015, 0.025, radius) * float(i)/8.; vec4 sample1 = texture(uTexture, uv + offset * dir); vec4 sample2 = texture(uTexture, uv - offset * dir); color += (sample1 + sample2) * weight; total_weight += 2.0 * weight; }return color / total_weight; }vec4 thresholdPass(vec4 color) { color.rgb = pow(color.rgb, vec3(1.0/2.2)); color.rgb = 1.2 * (color.rgb - 0.5) + 0.5; vec4 bloom = color * smoothstep(0.8200 - 0.1, 0.8200, luma(color)); return vec4(bloom.rgb, color.a); }vec4 blurCombinePass(vec2 uv, bool vertical, float radius, float intensity, bool diamond) { vec4 blurred = blur(uv, vertical, radius, diamond); return (thresholdPass(texture(uBgTexture, uv)) * 0.5 + blurred * intensity); }vec4 getColor(vec4 color) { return blurCombinePass(vTextureCoord, true, 40., 1.25, true); }void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); fragColor = getColor(color); }","#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uResolution;out vec4 fragColor;float getExponentialWeight(int index) { switch(index) { case 0: return 1.0000000000; case 1: return 0.7165313106; case 2: return 0.5134171190; case 3: return 0.3678794412; case 4: return 0.2636050919; case 5: return 0.1888756057; case 6: return 0.1353352832; case 7: return 0.0969670595; case 8: return 0.0694877157; default: return 0.0; } }vec4 blur(vec2 uv, bool vertical, float radius, bool diamond) { vec4 color = vec4(0.0); float total_weight = 0.0; float aspectRatio = uResolution.x/uResolution.y;vec2 dir; if (diamond) { dir = vertical ? vec2(1, 1) : vec2(1, -1); } else { dir = vertical ? vec2(0, 1) : vec2(1, 0); } dir *= vec2(0.0000, 1. - 0.0000); dir.x /= aspectRatio; vec4 center = texture(uTexture, uv); float center_weight = getExponentialWeight(0); color += center * center_weight; total_weight += center_weight;radius *= 0.0100; for (int i = 1; i <= 8; i++) { float weight = getExponentialWeight(i); float offset = mix(0.015, 0.025, radius) * float(i)/8.; vec4 sample1 = texture(uTexture, uv + offset * dir); vec4 sample2 = texture(uTexture, uv - offset * dir); color += (sample1 + sample2) * weight; total_weight += 2.0 * weight; }return color / total_weight; }vec4 blurPass(vec2 uv, bool vertical, float radius, float intensity, bool diamond) { return blur(uv, vertical, radius, diamond); }vec4 getColor(vec4 color) { return blurPass(vTextureCoord, false, 15., 1.1, true); }void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); fragColor = getColor(color); }","#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture;uniform vec2 uResolution;out vec4 fragColor;float luma(vec4 color) { return dot(color.rgb, vec3(0.299, 0.587, 0.114)); }float getExponentialWeight(int index) { switch(index) { case 0: return 1.0000000000; case 1: return 0.7165313106; case 2: return 0.5134171190; case 3: return 0.3678794412; case 4: return 0.2636050919; case 5: return 0.1888756057; case 6: return 0.1353352832; case 7: return 0.0969670595; case 8: return 0.0694877157; default: return 0.0; } }vec4 blur(vec2 uv, bool vertical, float radius, bool diamond) { vec4 color = vec4(0.0); float total_weight = 0.0; float aspectRatio = uResolution.x/uResolution.y;vec2 dir; if (diamond) { dir = vertical ? vec2(1, 1) : vec2(1, -1); } else { dir = vertical ? vec2(0, 1) : vec2(1, 0); } dir *= vec2(0.0000, 1. - 0.0000); dir.x /= aspectRatio; vec4 center = texture(uTexture, uv); float center_weight = getExponentialWeight(0); color += center * center_weight; total_weight += center_weight;radius *= 0.0100; for (int i = 1; i <= 8; i++) { float weight = getExponentialWeight(i); float offset = mix(0.015, 0.025, radius) * float(i)/8.; vec4 sample1 = texture(uTexture, uv + offset * dir); vec4 sample2 = texture(uTexture, uv - offset * dir); color += (sample1 + sample2) * weight; total_weight += 2.0 * weight; }return color / total_weight; }vec4 thresholdPass(vec4 color) { color.rgb = pow(color.rgb, vec3(1.0/2.2)); color.rgb = 1.2 * (color.rgb - 0.5) + 0.5; vec4 bloom = color * smoothstep(0.8200 - 0.1, 0.8200, luma(color)); return vec4(bloom.rgb, color.a); }vec4 blurCombinePass(vec2 uv, bool vertical, float radius, float intensity, bool diamond) { vec4 blurred = blur(uv, vertical, radius, diamond); return (thresholdPass(texture(uBgTexture, uv)) * 0.5 + blurred * intensity); }vec4 getColor(vec4 color) { return blurCombinePass(vTextureCoord, true, 15., 1.1, true); }void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); fragColor = getColor(color); }","#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uResolution;out vec4 fragColor;float getExponentialWeight(int index) { switch(index) { case 0: return 1.0000000000; case 1: return 0.7165313106; case 2: return 0.5134171190; case 3: return 0.3678794412; case 4: return 0.2636050919; case 5: return 0.1888756057; case 6: return 0.1353352832; case 7: return 0.0969670595; case 8: return 0.0694877157; default: return 0.0; } }vec4 blur(vec2 uv, bool vertical, float radius, bool diamond) { vec4 color = vec4(0.0); float total_weight = 0.0; float aspectRatio = uResolution.x/uResolution.y;vec2 dir; if (diamond) { dir = vertical ? vec2(1, 1) : vec2(1, -1); } else { dir = vertical ? vec2(0, 1) : vec2(1, 0); } dir *= vec2(0.0000, 1. - 0.0000); dir.x /= aspectRatio; vec4 center = texture(uTexture, uv); float center_weight = getExponentialWeight(0); color += center * center_weight; total_weight += center_weight;radius *= 0.0100; for (int i = 1; i <= 8; i++) { float weight = getExponentialWeight(i); float offset = mix(0.015, 0.025, radius) * float(i)/8.; vec4 sample1 = texture(uTexture, uv + offset * dir); vec4 sample2 = texture(uTexture, uv - offset * dir); color += (sample1 + sample2) * weight; total_weight += 2.0 * weight; }return color / total_weight; }vec4 blurPass(vec2 uv, bool vertical, float radius, float intensity, bool diamond) { return blur(uv, vertical, radius, diamond); }vec4 getColor(vec4 color) { return blurPass(vTextureCoord, false, 7.5, 1., false); }void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); fragColor = getColor(color); }","#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uResolution;out vec4 fragColor;float getExponentialWeight(int index) { switch(index) { case 0: return 1.0000000000; case 1: return 0.7165313106; case 2: return 0.5134171190; case 3: return 0.3678794412; case 4: return 0.2636050919; case 5: return 0.1888756057; case 6: return 0.1353352832; case 7: return 0.0969670595; case 8: return 0.0694877157; default: return 0.0; } }vec4 blur(vec2 uv, bool vertical, float radius, bool diamond) { vec4 color = vec4(0.0); float total_weight = 0.0; float aspectRatio = uResolution.x/uResolution.y;vec2 dir; if (diamond) { dir = vertical ? vec2(1, 1) : vec2(1, -1); } else { dir = vertical ? vec2(0, 1) : vec2(1, 0); } dir *= vec2(0.0000, 1. - 0.0000); dir.x /= aspectRatio; vec4 center = texture(uTexture, uv); float center_weight = getExponentialWeight(0); color += center * center_weight; total_weight += center_weight;radius *= 0.0100; for (int i = 1; i <= 8; i++) { float weight = getExponentialWeight(i); float offset = mix(0.015, 0.025, radius) * float(i)/8.; vec4 sample1 = texture(uTexture, uv + offset * dir); vec4 sample2 = texture(uTexture, uv - offset * dir); color += (sample1 + sample2) * weight; total_weight += 2.0 * weight; }return color / total_weight; }vec4 blurPass(vec2 uv, bool vertical, float radius, float intensity, bool diamond) { return blur(uv, vertical, radius, diamond); }vec4 getColor(vec4 color) { return blurPass(vTextureCoord, true, 7.5, 1., false); }void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); fragColor = getColor(color); }","#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture;uvec2 pcg2d(uvec2 v) { v = v * 1664525u + 1013904223u; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; v ^= v >> 16; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; return v; }float randFibo(vec2 p) { uvec2 v = floatBitsToUint(p); v = pcg2d(v); uint r = v.x ^ v.y; return float(r) / float(0xffffffffu); }out vec4 fragColor;float luma(vec4 color) { return dot(color.rgb, vec3(0.299, 0.587, 0.114)); }vec4 finalPass(vec4 bloomColor) { float dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0; bloomColor.rgb *= vec3(0.0784313725490196, 0.9098039215686274, 0.5215686274509804); bloomColor.rgb += dither; bloomColor.a = luma(bloomColor); vec4 sceneColor = texture(uBgTexture, vTextureCoord); vec4 finalColor = mix(sceneColor, sceneColor + bloomColor, 0.6100 * 1.75); return finalColor; }vec4 getColor(vec4 color) { return finalPass(color); }void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); fragColor = getColor(color); }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"downSample":0.5,"depth":false,"uniforms":{},"isBackground":false,"passes":[{"prop":"pass","value":1,"downSample":0.25},{"prop":"pass","value":2,"downSample":0.25,"includeBg":true},{"prop":"pass","value":3,"downSample":0.25},{"prop":"pass","value":4,"downSample":0.25,"includeBg":true},{"prop":"pass","value":5,"downSample":0.5},{"prop":"pass","value":6,"downSample":0.5,"includeBg":true},{"prop":"pass","value":7,"downSample":1,"includeBg":true}]},"id":"effect12"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"sphere","usesPingPong":false,"radius":0.79,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"parentLayer":"b7552748-e750-4446-9fa5-ab54d4a580f5","animating":false,"isMask":0,"states":{"appear":[{"local":{"pendingChanges":{},"changeDebouncer":null,"dragSession":null},"type":"appear","id":"792c7bac-d8b0-40da-b266-9732d124bbaa","prop":"radius","transition":{"ease":"easeInOutQuart","delay":500,"duration":3000},"complete":false,"progress":0,"value":0,"endValue":20,"initialized":false,"breakpoints":[],"loop":"none","loopDelay":0,"uniformData":{"type":"1f","name":"uRadius"}}],"scroll":[],"hover":[]},"compiledFragmentShaders":["#version 300 es\nprecision highp float; in vec3 vVertexPosition; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform float uRadius; uniform vec2 uMousePos; uniform vec2 uResolution;const float STEPS = 16.0; const float PI = 3.1415926;vec3 chromaticAbberation(vec2 st, float angle, float amount, float blend) { float aspectRatio = uResolution.x/uResolution.y; float rotation = angle * 360.0 * PI / 180.0; vec2 aberrated = amount * vec2(0.1 * sin(rotation) * aspectRatio, 0.1 * cos(rotation)); aberrated *= distance(st, vec2(0.5)) * 2.0; vec4 red = vec4(0); vec4 blue = vec4(0); vec4 green = vec4(0); float invSteps = 1.0 / STEPS; float invStepsHalf = invSteps * 0.5; for(float i = 1.0; i <= STEPS; i++) { vec2 offset = aberrated * (i * invSteps); red += texture(uTexture, st - offset) * invSteps; blue += texture(uTexture, st + offset) * invSteps; }for (float i = 0.0; i <= STEPS; i++) { vec2 offset = aberrated * ((i * invSteps) - 0.5); green += texture(uTexture, st + offset) * invSteps; } return vec3(red.r, green.g, blue.b); }vec2 sphericalTransformation( float u, float v, float uCenter, float vCenter, float lensRadius, float tau) { float aspectRatio = uResolution.x/uResolution.y; u -= uCenter; v -= vCenter;float s = sqrt(u * u + v * v); if (s > lensRadius) return vec2(u + uCenter, v + vCenter);float z = sqrt(lensRadius * lensRadius - s * s);float uAlpha = (1.0 - (1.0 / tau)) * asin(u / lensRadius); float vAlpha = (1.0 - (1.0 / tau)) * asin(v / lensRadius);u = uCenter + z * sin(uAlpha); v = vCenter + z * sin(vAlpha);return vec2(u/aspectRatio, v); }float circularIn(float t) { return 1.0 - sqrt(1.0 - t * t); }vec2 fisheyeTransformation( float u, float v, float uCenter, float vCenter, float lensRadius, float distortionScale ) { float aspectRatio = uResolution.x / uResolution.y;vec2 dir = vec2(u - uCenter, v - vCenter);dir.x /= lensRadius; dir.y /= lensRadius;float dist = length(dir) * 0.15;if (dist < 1.0) { float theta = atan(dir.y, dir.x);float r = dist * 2.0 * PI; float z = sqrt(1.0 - r * r) + 0.25; float rDist = atan(r, z) / PI; float newDist = mix(dist, rDist, 5.);dir.x = newDist * cos(theta); dir.y = newDist * sin(theta); }dir.x *= lensRadius; dir.y *= lensRadius;return mix(vec2(u/aspectRatio, v), vec2(uCenter/aspectRatio, vCenter) + dir, 0.2800); }vec2 discTransformation( float u, float v, float uCenter, float vCenter, float lensRadius, float distortionScale) { float aspectRatio = uResolution.x/uResolution.y; u -= uCenter; v -= vCenter;float s = sqrt(u * u + v * v); if (s > lensRadius) return vec2(u + uCenter, v + vCenter); float r = sqrt(u * u + v * v) / lensRadius; if(r == 0.0) return vec2(uCenter, vCenter);r = pow(r, distortionScale); float theta = atan(r); float rad = theta / r;u = rad * u + uCenter; v = rad * v + vCenter;return vec2(u/aspectRatio, v); }out vec4 fragColor; void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); float aspectRatio = uResolution.x/uResolution.y; uv.x = uv.x * aspectRatio; vec2 sphereCoords = uv; vec2 pos = vec2(0.4954655380894801, 0.3210399032648126) + mix(vec2(0), (uMousePos-0.5), 0.0000); pos.x *= aspectRatio;float radius = uRadius * uResolution.x/max(uResolution.x, uResolution.y);if(0 == 0) { sphereCoords = sphericalTransformation( mix(sphereCoords.x, 1.-sphereCoords.x, 0.0000), mix(sphereCoords.y, 1.-sphereCoords.y, 0.0000), mix(pos.x, 1.-pos.x, 0.0000), mix(pos.y, 1.-pos.y, 0.0000), radius/2., 1. + 0.2800 * 9. ); } else if(0 == 1) { sphereCoords = discTransformation( mix(sphereCoords.x, 1.-sphereCoords.x, 0.0000), mix(sphereCoords.y, 1.-sphereCoords.y, 0.0000), mix(pos.x, 1.-pos.x, 0.0000), mix(pos.y, 1.-pos.y, 0.0000), radius/2., 1. + 0.2800 * 9. ); } else if(0 == 2) { sphereCoords = fisheyeTransformation( mix(sphereCoords.x, 1.-sphereCoords.x, 0.0000), mix(sphereCoords.y, 1.-sphereCoords.y, 0.0000), mix(pos.x, 1.-pos.x, 0.0000), mix(pos.y, 1.-pos.y, 0.0000), radius/2., 1. + 0.2800 * 9. ); }vec2 scaledCoords = (sphereCoords - 0.5) + 0.5; vec4 sphere = texture(uTexture, clamp(scaledCoords, 0.0, 1.0)); float distFromPos = distance(uv, pos); float edgeSmooth = 0.001; float insideSphere = 1.0 - smoothstep(radius/2.0 - edgeSmooth, radius/2.0, distFromPos); float insideSphereAlpha = 1.0 - smoothstep(radius/2.0 + 0.002 - edgeSmooth, radius/2.0 + 0.002, distFromPos); sphere.rgb = chromaticAbberation(scaledCoords, atan(scaledCoords.y, scaledCoords.x), distFromPos * 0.5000, 1.0); color = mix(color, sphere, insideSphere); color.rgb += vec3((0.5000-0.5)*2.) * mix(0., circularIn(smoothstep(0., radius, distFromPos)), insideSphere); if(0 == 1) { color.a = insideSphereAlpha; color.rgb = mix(vec3(0), color.rgb, insideSphereAlpha); } fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect13"}],"options":{"name":"DootLord Meme 2025","fps":60,"dpi":1.5,"scale":1,"includeLogo":false,"isProduction":false},"version":"1.4.31","id":"iTNb060BLNCQz8hCUyyb"}
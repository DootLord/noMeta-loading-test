{"history":[{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"gradient","usesPingPong":false,"speed":0.25,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform vec2 uMousePos;vec3 getColor(int index) { switch(index) { case 0: return vec3(0.08235294117647059, 0.08235294117647059, 0.08235294117647059); case 1: return vec3(0, 0, 0); case 2: return vec3(0, 0, 0); case 3: return vec3(0, 0, 0); case 4: return vec3(0, 0, 0); case 5: return vec3(0, 0, 0); case 6: return vec3(0, 0, 0); case 7: return vec3(0, 0, 0); case 8: return vec3(0, 0, 0); case 9: return vec3(0, 0, 0); case 10: return vec3(0, 0, 0); case 11: return vec3(0, 0, 0); case 12: return vec3(0, 0, 0); case 13: return vec3(0, 0, 0); case 14: return vec3(0, 0, 0); case 15: return vec3(0, 0, 0); default: return vec3(0.0); } }const float PI = 3.14159265;vec2 rotate(vec2 coord, float angle) { float s = sin(angle); float c = cos(angle); return vec2( coord.x * c - coord.y * s, coord.x * s + coord.y * c ); }out vec4 fragColor;vec3 getColor(vec2 uv) {return vec3(0.08235294117647059, 0.08235294117647059, 0.08235294117647059); }void main() {vec2 uv = vTextureCoord; vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000); uv -= pos; uv /= (0.5000*2.); uv = rotate(uv, (0.0000 - 0.5) * 2. * PI); vec4 color = vec4(getColor(uv), 1.); fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"],"data":{"downSample":0.5,"depth":false,"uniforms":{},"isBackground":true},"id":"effect"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"fbm","usesPingPong":false,"speed":0.25,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"parentLayer":"2479bc17-2a66-419e-a392-28713593cd7e","animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform sampler2D uTexture; uniform float uTime;uniform vec2 uMousePos; uniform vec2 uResolution;float ease (int easingFunc, float t) { return t; }vec3 hash33(vec3 p3) { p3 = fract(p3 * vec3(0.1031, 0.11369, 0.13787)); p3 += dot(p3, p3.yxz + 19.19); return -1.0 + 2.0 * fract(vec3( (p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y, (p3.y + p3.z) * p3.x )); }float perlin_noise(vec3 p) { vec3 pi = floor(p); vec3 pf = p - pi;vec3 w = pf * pf * (3.0 - 2.0 * pf);float n000 = dot(pf - vec3(0.0, 0.0, 0.0), hash33(pi + vec3(0.0, 0.0, 0.0))); float n100 = dot(pf - vec3(1.0, 0.0, 0.0), hash33(pi + vec3(1.0, 0.0, 0.0))); float n010 = dot(pf - vec3(0.0, 1.0, 0.0), hash33(pi + vec3(0.0, 1.0, 0.0))); float n110 = dot(pf - vec3(1.0, 1.0, 0.0), hash33(pi + vec3(1.0, 1.0, 0.0))); float n001 = dot(pf - vec3(0.0, 0.0, 1.0), hash33(pi + vec3(0.0, 0.0, 1.0))); float n101 = dot(pf - vec3(1.0, 0.0, 1.0), hash33(pi + vec3(1.0, 0.0, 1.0))); float n011 = dot(pf - vec3(0.0, 1.0, 1.0), hash33(pi + vec3(0.0, 1.0, 1.0))); float n111 = dot(pf - vec3(1.0, 1.0, 1.0), hash33(pi + vec3(1.0, 1.0, 1.0)));float nx00 = mix(n000, n100, w.x); float nx01 = mix(n001, n101, w.x); float nx10 = mix(n010, n110, w.x); float nx11 = mix(n011, n111, w.x);float nxy0 = mix(nx00, nx10, w.y); float nxy1 = mix(nx01, nx11, w.y);float nxyz = mix(nxy0, nxy1, w.z);return nxyz; } const float PI = 3.14159265359; mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }mat2 rotHalf = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));float fbm (in vec3 st) { float value = 0.0; float amp = .25; float frequency = 0.; float aM = (0.1 + 0.5000 * .65); vec2 shift = vec2(100.0); for (int i = 0; i < 6; i++) { value += amp * perlin_noise(st); st.xy *= rotHalf * 2.5; st.xy += shift; amp *= aM; } return value; }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; float aspectRatio = uResolution.x/uResolution.y; float multiplier = 6.0 * (0.7700 / ((aspectRatio + 1.) / 2.));vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000); vec2 pos = mix(vec2(0.5, 0.5), mPos, floor(1.0000)); float mDist = ease(0, max(0.,1.-distance(uv * vec2(aspectRatio, 1), mPos * vec2(aspectRatio, 1)) * 4. * (1. - 1.0000))); vec2 st = ((uv - pos) * vec2(aspectRatio, 1)) * multiplier * aspectRatio; st = rot(0.0000 * -2. * PI) * st; vec2 drift = vec2(uTime * 0.005) * (0.5000 * 2.);float time = uTime * 0.025;vec2 r = vec2( fbm(vec3(st - drift + vec2(1.7, 9.2), 0.0000*25. + time)), fbm(vec3(st - drift + vec2(8.2, 1.3), 0.0000*25. + time)) );float f = fbm(vec3(st + r - drift, 0.0000*25. + time)) * 0.5000;vec2 offset = (f * 2. + (r * 0.5000));vec4 color = texture(uTexture, uv + offset * mDist); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect1"},{"breakpoints":[],"visible":true,"locked":false,"aspectRatio":1.7786561264822136,"layerName":"","userDownsample":1,"isElement":true,"opacity":0,"effects":["2479bc17-2a66-419e-a392-28713593cd7e"],"displace":0,"trackMouse":0,"anchorPoint":"center","mouseMomentum":0,"blendMode":"NORMAL","bgDisplace":0,"mask":0,"maskBackground":{"type":"Vec3","_x":0,"_y":0,"_z":0},"maskAlpha":0,"maskDepth":0,"dispersion":0,"axisTilt":0,"states":{"appear":[{"local":{"pendingChanges":{},"changeDebouncer":null,"dragSession":null},"type":"appear","id":"17b7c4cb-e4b4-430d-9f5c-44a8f822575b","prop":"opacity","transition":{"duration":1000,"ease":"easeInOutQuart","delay":1000},"complete":false,"progress":0,"value":0,"endValue":1,"initialized":false,"breakpoints":[],"loop":"none","loopDelay":0,"uniformData":{"type":"1f","name":"uOpacity"}}],"scroll":[],"hover":[]},"layerType":"image","imageLoaded":false,"width":1973.3824110671937,"widthMode":"fixed","height":1109.4794444444444,"heightMode":"auto","left":0.45725358201581023,"leftMode":"relative","top":0.4869558641975308,"topMode":"relative","rotation":0,"trackAxes":"xy","fitToCanvas":0,"src":"https://assets.unicorn.studio/images/j4zenaojE3VJilKLb7choDB1YK42/skull-and-crossbones-1920-x-1080-5vvvdfwlwk88jicg.webp","naturalWidth":900,"naturalHeight":506,"compiledFragmentShaders":["#version 300 es\nprecision highp float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uBgTexture; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform float uOpacity; uniform int uSampleBg;out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.0000);uv = uv - pos;vec4 color = texture(uTexture, uv); vec4 background = vec4(0);if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); }color = mix(background, color / max(color.a, 0.0001), color.a * uOpacity);fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision highp float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"uniforms":{}},"id":"image"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"godrays","usesPingPong":false,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"parentLayer":"c4580d8b-e85b-4c37-bb97-09cef606490f","animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;const float MAX_ITERATIONS = 64.; const float PI2 = 6.28318530718; const float EPSILON = 0.0001; const float stepFactor = 0.0098;vec4 getBrightAreas(vec2 uv) { vec4 color = texture(uTexture, uv); float lum = dot(color.rgb, vec3(0.299, 0.587, 0.114)); color = color * smoothstep(0.5000 - 0.1, 0.5000, lum); return color; }vec4 getColor(vec2 uv) { return getBrightAreas(uv); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); if(0 == 2) { fragColor = color;} else { fragColor = color; } }","#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uMousePos;uvec2 pcg2d(uvec2 v) { v = v * 1664525u + 1013904223u; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; v ^= v >> 16; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; return v; }float randFibo(vec2 p) { uvec2 v = floatBitsToUint(p); v = pcg2d(v); uint r = v.x ^ v.y; return float(r) / float(0xffffffffu); }const float MAX_ITERATIONS = 64.; const float PI2 = 6.28318530718; const float EPSILON = 0.0001; const float stepFactor = 0.0098;vec4 godRays(vec2 st, float decay) { vec3 color = vec3(0); float offset = (0.25 + min(1., 0.5000)) * stepFactor; vec2 pos = vec2(0.5, 0.5) - mix(vec2(0), (vec2(1. - uMousePos.x, 1. - uMousePos.y) - 0.5), 0.0000); float weight = 1.0; float bnoz = randFibo(st) * 0.5000; float distanceInfo = 0.0; vec2 marchPos = st;for (float i = 0.0; i < MAX_ITERATIONS; i += 4.0) { for (float j = 0.0; j < 4.0; j++) { float bno = randFibo(st + vec2(i/MAX_ITERATIONS + j/4.0)) * 0.5000; vec2 offbno = vec2(cos(bno) - 0.5, sin(bno) - 0.5); float x = min(0.999, (i + j) * offset) + bnoz * 0.02; float y = min(0.999, (i + j)); marchPos = st * (1.0 - x) + vec2(x * 0.5) + (pos - 0.5) * x + offbno * 0.02 * 0.2500 * x; color += texture(uTexture, marchPos).rgb * weight; distanceInfo += y * weight; weight *= decay; if(weight < 0.01) break; } } return vec4(color / MAX_ITERATIONS, distance(st, marchPos)); }vec4 getGodRays(vec2 uv) { if(0.5000 == 0.) { return vec4(0); } vec4 rays = godRays(uv, 0.972); rays.rgb *= vec3(1, 1, 1); vec4 color; color.rgb = rays.rgb; color.a = rays.a; return color; }vec4 getColor(vec2 uv) { return getGodRays(uv); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); if(1 == 2) { fragColor = color;} else { fragColor = color; } }","#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture; uniform sampler2D uBlueNoise;uniform vec2 uResolution;const float MAX_ITERATIONS = 64.; const float PI2 = 6.28318530718; const float EPSILON = 0.0001; const float stepFactor = 0.0098;float luma(vec4 color) { return dot(color.rgb, vec3(0.299, 0.587, 0.114)); }float getBlueNoiseOffset(vec2 st) { ivec2 texSize = ivec2(512, 512); vec4 blueNoise = texelFetch(uBlueNoise, ivec2(fract(st * (uResolution)/vec2(texSize) * vec2(texSize.x/texSize.y, 1.0)) * vec2(texSize)) % texSize, 0); return mod((blueNoise.r - 0.5) * PI2, PI2); }vec4 composite(vec2 uv) { vec4 godrays = texture(uTexture, uv); float distanceInfo = godrays.a; float luminance = luma(godrays); float blueNoise = getBlueNoiseOffset(uv) - 0.5; vec2 circNoise = vec2(cos(blueNoise), sin(blueNoise)); float brightnessScale = (1. - (luminance + 0.25)); vec2 offset = circNoise * 0.05 * pow(brightnessScale, 3.) * distanceInfo * 2.; vec4 color = texture(uTexture, uv + offset); vec4 bg = texture(uBgTexture, uv);color.rgb = bg.rgb + (color.rgb * 2.9 * 0.5000 + blueNoise * 0.001); color.a = bg.a + color.r; return color; }vec4 getColor(vec2 uv) { return composite(uv); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); if(2 == 2) { fragColor = color;} else { fragColor = color; } }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false,"passes":[{"prop":"pass","value":1,"downSample":0.5},{"prop":"pass","value":2,"includeBg":true}],"texture":{"src":"https://assets.unicorn.studio/media/blue_noise_med.png","sampler":"uBlueNoise"}},"id":"effect2"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"guilloche","usesPingPong":false,"amount":1,"speed":0.25,"texture":false,"parentLayer":"398a8536-9bdf-41f5-b9a3-7224f6cf68e7","animating":true,"mouseMomentum":0,"isMask":0,"states":{"appear":[{"local":{"pendingChanges":{},"changeDebouncer":null,"dragSession":null},"type":"appear","id":"3007a857-b530-45e1-b78e-db47adadcfc7","prop":"amount","transition":{"delay":1000,"duration":1000,"ease":"easeInOutQuart"},"complete":false,"progress":0,"value":1,"endValue":0,"initialized":false,"breakpoints":[],"loop":"none","loopDelay":0,"uniformData":{"type":"1f","name":"uAmount"}}],"scroll":[],"hover":[]},"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uAmount; uniform float uTime;uniform vec2 uResolution;const float PI = 3.14159265359; mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }float getWaveLine(vec2 uv, float intensity) { float lineFreq = 150.0 * 0.5300; float waveAmplitude = 0.04 * 0.5000; float waveFreq = 8.0 * 0.5000; float sineOffset = waveAmplitude * sin((uv.x + uTime*0.005) * waveFreq * 2.0 * 3.14159); uv.y += sineOffset; float lineWidth = mix(0., 1., intensity);float linePosition = fract(uv.y * lineFreq); float gradient = smoothstep(0., lineWidth, linePosition) - smoothstep(1.0 - lineWidth, 1.0, linePosition);return smoothstep(0., lineWidth*1.5, gradient*gradient); }float getZigZagLine(vec2 uv, float lineWidth) { float lineFreq = 150.0 * 0.5300; float waveAmplitude = 0.8 * 0.5000; float flipInterval = 0.2 * (1. - 0.5000 + 0.001); float flip = mod(floor(uv.x / flipInterval), 2.0); uv.x -= flipInterval * 0.5 + floor(uv.x / flipInterval) * flipInterval + uTime*0.005; uv = (uv * rot(waveAmplitude * (flip * 2.0 - 1.0))); uv.x += flipInterval * 0.5;float linePosition = fract(uv.y * lineFreq);float gradient = smoothstep(0.0, lineWidth, linePosition) - smoothstep(1.0 - lineWidth, 1.0, linePosition); return smoothstep(0., lineWidth*1.5, gradient*gradient); }float getGuillocheLine(vec2 uv, float lineWidth) { float lineFreq = 150.0 * 0.5300; float waveAmplitude = 0.04 * 0.5000; float waveFreq = 8.0 * 0.5000; uv.x += waveAmplitude * sin((uv.y + uTime*0.005) * waveFreq * 2.0 * 3.14159);float linePosition = fract(uv.x * lineFreq);float gradient = smoothstep(0.0, lineWidth, linePosition) - smoothstep(1.0 - lineWidth, 1.0, linePosition); return smoothstep(0., 1., gradient*gradient); }float getGuillocheFull(vec2 uv, float lineWidth) { float mult = getGuillocheLine(uv * rot(0.25 * 2. * PI), lineWidth) * 0.75; float add = getGuillocheLine(uv * rot(0.25 * 2. * PI), lineWidth) + getGuillocheLine(uv, lineWidth); return mix(add, mult, smoothstep(0., 1., lineWidth)); }vec3 photoshop_desaturate(vec3 color) { float bw = (min(color.r, min(color.g, color.b)) + max(color.r, max(color.g, color.b))) * 0.5; return vec3(bw); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord;vec4 color = texture(uTexture, uv); vec3 linographed = vec3(0);float red = 1.-color.r; float green = 1.-color.g; float blue = 1.-color.b;vec2 st = rot(0.0000 * -1. * 2. * PI) * ((uv * vec2(uResolution.x/uResolution.y, 1.)) - vec2(0.5, 0.5)); if(0 == 0) { linographed = vec3( getGuillocheFull(st, red), getGuillocheFull(st, green), getGuillocheFull(st, blue) ); } if(0 == 1) { linographed = vec3( getWaveLine(st, red), getWaveLine(st, green), getWaveLine(st, blue) ); } if(0 == 2) { linographed = vec3( getZigZagLine(st, red), getZigZagLine(st, green), getZigZagLine(st, blue) ); }color.rgb = mix(color.rgb, linographed, uAmount); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect3"},{"breakpoints":[{"min":992,"name":"Desktop","max":null,"props":{"angle":0.1809,"pos":{"type":"Vec2","_x":0.5397097944377268,"_y":0.3591172914147521},"radius":0.15}},{"props":{"radius":0.244,"angle":0.3078,"pos":{"type":"Vec2","_x":0.6103071032152049,"_y":0.23698911729141475}},"name":"Mobile","max":575,"min":0}],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"beam","usesPingPong":false,"skew":1,"mix":0,"speed":0.58,"trackMouse":0.01,"trackAxes":"xy","mouseMomentum":0,"texture":false,"parentLayer":"8d16da61-6e41-4fe8-af06-a3c080120797","animating":true,"isMask":0,"states":{"appear":[{"local":{"pendingChanges":{},"changeDebouncer":null,"dragSession":null},"type":"appear","id":"b61b2109-6f8d-4d55-8bc3-49695f344481","prop":"mix","transition":{"ease":"easeInOutQuart","duration":1000,"delay":1500},"complete":false,"progress":0,"value":0,"endValue":1,"initialized":false,"breakpoints":[],"loop":"none","loopDelay":0,"uniformData":{"type":"1f","name":"uMix"}},{"local":{"pendingChanges":{},"changeDebouncer":null,"dragSession":null},"type":"appear","id":"6eef63b4-0b0f-4561-89e0-2ca857f0d4d5","prop":"skew","transition":{"duration":500,"ease":"easeInOutQuart","delay":2000},"complete":false,"progress":0,"value":1,"endValue":0.53,"initialized":false,"breakpoints":[],"loop":"none","loopDelay":0,"uniformData":{"type":"1f","name":"uSkew"}}],"scroll":[],"hover":[]},"compiledFragmentShaders":["#version 300 es\nprecision highp float; precision highp int;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uPos; uniform float uRadius; uniform float uAngle; uniform float uTime; uniform float uSkew; uniform float uMix;uniform vec2 uMousePos; uniform vec2 uResolution; vec3 blend (int blendMode, vec3 src, vec3 dst) { return src + dst; }uvec2 pcg2d(uvec2 v) { v = v * 1664525u + 1013904223u; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; v ^= v >> 16; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; return v; }float randFibo(vec2 p) { uvec2 v = floatBitsToUint(p); v = pcg2d(v); uint r = v.x ^ v.y; return float(r) / float(0xffffffffu); }vec3 Tonemap_tanh(vec3 x) { x = clamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }out vec4 fragColor;const float PI = 3.14159265359; const float TWO_PI = 2.0 * PI;float luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }vec3 drawSpiral(vec2 uv, vec2 center, float scale) { uv.x *= uResolution.x/uResolution.y; center.x *= uResolution.x/uResolution.y; vec2 skew = vec2(uSkew, 1. - uSkew) * 2.;uv *= skew; center *= skew;vec3 total = vec3(0);float angle = atan(uv.y, uv.x); float dist = length(uv - center);for(float i = 0.; i < 3.; i++) { float angle = (uAngle + 0.5) * dist + i/3. - uTime * 0.01; float thickness = 0.5000 * 0.5; vec2 s = vec2(0.5 + thickness, 0.5 - thickness) * 2.; vec2 st = uv * rot(angle * TWO_PI) * s; vec2 c = center * rot(angle * TWO_PI) * s; float dist = distance(st, c); float radius = scale * 0.25;vec3 brightness = (radius / dist) * vec3(0.06274509803921569, 0.7137254901960784, 0.403921568627451);total += brightness * 0.3333; }return total; }vec3 getBeam(vec2 uv) { vec2 pos = uPos + mix(vec2(0), (uMousePos-0.5), 0.0100); return drawSpiral(uv, pos, uRadius); }void main() { vec2 uv = vTextureCoord; vec4 bg = texture(uTexture, uv);vec3 beam = getBeam(uv); float dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0;vec3 blended = blend(1, Tonemap_tanh(beam), bg.rgb); vec3 result = mix(bg.rgb, blended, uMix); result += dither;vec4 color = vec4(result, max(bg.a, luma(beam))); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{"radius":{"name":"uRadius","type":"1f","value":0.5},"angle":{"name":"uAngle","type":"1f","value":0},"pos":{"name":"uPos","type":"2f","value":{"type":"Vec2","_x":0.5,"_y":0.5}}},"isBackground":false},"id":"effect4"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"coloration","usesPingPong":false,"texture":false,"parentLayer":"62f7477e-b53a-49ae-a96d-7b79a7368506","animating":false,"mouseMomentum":0,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uResolution;vec3 getFilteredColor(vec3 color) { return color; }float hueToRgb(float p, float q, float t) { if (t < 0.0) t += 1.0; if (t > 1.0) t -= 1.0; if (t < 1.0 / 6.0) return p + (q - p) * 6.0 * t; if (t < 1.0 / 2.0) return q; if (t < 2.0 / 3.0) return p + (q - p) * (2.0 / 3.0 - t) * 6.0; return p; }vec3 hslToRgb(vec3 hsl) { float h = hsl.x; float s = hsl.y; float l = hsl.z; vec3 rgb = vec3(l); if (s != 0.0) { float q = l < 0.5 ? l * (1.0 + s) : l + s - l * s; float p = 2.0 * l - q; rgb.r = hueToRgb(p, q, h + 1.0 / 3.0); rgb.g = hueToRgb(p, q, h); rgb.b = hueToRgb(p, q, h - 1.0 / 3.0); } return rgb; }vec3 rgbToHsl(vec3 rgb) { float max = max(max(rgb.r, rgb.g), rgb.b); float min = min(min(rgb.r, rgb.g), rgb.b); float h, s, l = (max + min) / 2.0;if (max == min) { h = s = 0.0; } else { float d = max - min; s = l > 0.5 ? d / (2.0 - max - min) : d / (max + min); if (max == rgb.r) { h = (rgb.g - rgb.b) / d + (rgb.g < rgb.b ? 6.0 : 0.0); } else if (max == rgb.g) { h = (rgb.b - rgb.r) / d + 2.0; } else if (max == rgb.b) { h = (rgb.r - rgb.g) / d + 4.0; } h /= 6.0; }return vec3(h, s, l); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv);if(color.a <= 0.001) { fragColor = vec4(0); return; }color.rgb = rgbToHsl(color.rgb); color.x = fract(color.x + 1.0000); color.y = clamp(color.y * 2.0000, 0.0, 1.0); color.z = clamp(color.z + 0.0000, 0.0, 1.0); color.rgb = hslToRgb(color.rgb); color.rgb = getFilteredColor(color.rgb);color.rgb = 1.0000 * (color.rgb - 0.5) + 0.5;color.r = clamp(color.r + 0.0000, 0.0, 1.0); color.b = clamp(color.b - 0.0000, 0.0, 1.0);color.rgb = pow(max(color.rgb, 0.0001), vec3(1.0 / (max(0.0800, 0.0) + 1.0)));vec3 avgSurround = ( texture(uTexture, uv + vec2(-1.0, 0.0) / uResolution).rgb + texture(uTexture, uv + vec2(1.0, 0.0) / uResolution).rgb + texture(uTexture, uv + vec2(0.0, -1.0) / uResolution).rgb + texture(uTexture, uv + vec2(0.0, 1.0) / uResolution).rgb) / 4.0; color.rgb += 1.0000 * (color.rgb - avgSurround);color = vec4(clamp(color.rgb, 0.0, 1.0), color.a); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect5"},{"breakpoints":[{"name":"Desktop","props":{"width":450},"max":null,"min":992},{"name":"Mobile","max":575,"props":{"width":370},"min":0}],"visible":true,"locked":false,"aspectRatio":0.9895833333333333,"layerName":"","userDownsample":1,"isElement":true,"opacity":1,"effects":["d139944c-f7db-4405-a658-7991ccd77af3","4882a347-f3b1-4b4c-aa60-42d54e84913e","10d5aa27-50ba-41f9-abd9-0818e4a98460","c4580d8b-e85b-4c37-bb97-09cef606490f","398a8536-9bdf-41f5-b9a3-7224f6cf68e7","8d16da61-6e41-4fe8-af06-a3c080120797","62f7477e-b53a-49ae-a96d-7b79a7368506"],"displace":0,"trackMouse":0,"anchorPoint":"center","mouseMomentum":0,"blendMode":"NORMAL","bgDisplace":0,"mask":0,"maskBackground":{"type":"Vec3","_x":0,"_y":0,"_z":0},"maskAlpha":0,"maskDepth":0,"dispersion":0,"axisTilt":0,"states":{"appear":[],"scroll":[],"hover":[]},"layerType":"image","imageLoaded":false,"width":450,"widthMode":"fixed","height":454.7368421052632,"heightMode":"auto","left":0.5,"leftMode":"relative","top":0.4866989117291415,"topMode":"relative","rotation":0,"trackAxes":"xy","fitToCanvas":0,"src":"https://assets.unicorn.studio/images/j4zenaojE3VJilKLb7choDB1YK42/DootLord-Photoroom.png","naturalWidth":760,"naturalHeight":768,"compiledFragmentShaders":["#version 300 es\nprecision highp float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uBgTexture; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform int uSampleBg;out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.0000);uv = uv - pos;vec4 color = texture(uTexture, uv); vec4 background = vec4(0);if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); }color = mix(background, color / max(color.a, 0.0001), color.a * 1.0000);fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision highp float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"uniforms":{}},"id":"image1"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"texturize","usesPingPong":false,"amount":0.55,"offsetX":0,"speed":0.79,"texture":false,"parentLayer":"10d5aa27-50ba-41f9-abd9-0818e4a98460","animating":false,"mouseMomentum":0,"isMask":0,"states":{"appear":[{"local":{"pendingChanges":{},"changeDebouncer":null,"dragSession":null},"type":"appear","id":"a2daa4f4-d6c0-464c-811c-ca1c3e5cefc6","prop":"amount","transition":{"duration":2000,"ease":"easeInOutQuart","delay":0},"complete":false,"progress":0,"value":0.48,"endValue":1,"initialized":false,"breakpoints":[],"loop":"none","loopDelay":0,"uniformData":{"type":"1f","name":"uAmount"}},{"local":{"pendingChanges":{},"changeDebouncer":null,"dragSession":null},"type":"appear","id":"24013c06-858f-41b3-adfa-0c184272f0b7","prop":"offsetX","transition":{"duration":2000,"delay":0,"ease":"easeInOutQuart"},"complete":false,"progress":0,"value":0.5,"endValue":0,"initialized":false,"breakpoints":[],"loop":"none","loopDelay":0,"uniformData":{"type":"1f","name":"uOffsetX"}}],"scroll":[],"hover":[]},"compiledFragmentShaders":["#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform float uAmount; uniform float uOffsetX; uniform float uTime;uvec2 pcg2d(uvec2 v) { v = v * 1664525u + 1013904223u; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; v ^= v >> 16; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; return v; }float randFibo(vec2 p) { uvec2 v = floatBitsToUint(p); v = pcg2d(v); uint r = v.x ^ v.y; return float(r) / float(0xffffffffu); } out vec4 fragColor;void main() { vec2 uv = vTextureCoord; float timeRand1 = randFibo(vec2(floor(uTime * 0.5) * 2. + 0.001, 0.5)); float timeRand2 = randFibo(vec2(floor(uTime * 0.5) * 2. + 1.001, 0.5)); float sizeX = uAmount * 0.2 * timeRand1; float sizeY = uAmount * 0.2 * timeRand2; float floorY = floor(uv.y/sizeY) + 0.005; float floorX = floor(uv.x/sizeX) + 0.005; float phase = 0.0000 * 0.01; float chromab = 0.5800 * 0.75; float offset = 0.;vec2 blockSize = vec2(50.0, 50.0) * (1.0 - uAmount); vec2 blockUV = floor(uv * blockSize) / blockSize; float blockRand = randFibo(blockUV); float blockTimeRand = timeRand1; float blockNoise = mix( 1., step(0.8, randFibo(vec2(blockTimeRand, blockRand))), 0.5300 );float offsetX = uOffsetX * 0.5 * blockNoise; float offsetY = 0.0000 * 0.5 * blockNoise;float randY = randFibo(vec2(sin(floorY + offset + phase), 0.5)); float randX = randFibo(vec2(cos(floorX + offset + phase), 0.5)); float glitchModX = max(0.005, sign(randY - 0.5 - (1. - 0.6300*2.)/2.)); float glitchModY = max(0.005, sign(randX - 0.5 - (1. - 0.6300*2.)/2.));float randOffX = randFibo(vec2(floorY + offset * glitchModX + phase, 0.7)); float randOffY = randFibo(vec2(floorX + offset * glitchModY + phase, 0.9)); float offX = (randOffX * offsetX - offsetX/2.)/5.; float offY = (randOffY * offsetY - offsetY/2.)/5.;offX = clamp(offX, -1.0, 1.0); offY = clamp(offY, -1.0, 1.0);uv.x = mix(uv.x, uv.x + offX * 2., glitchModX); uv.y = mix(uv.y, uv.y + offY * 2., glitchModY);float waveFreq = 30.0; float waveAmp = 0.005 * 0.2000; float timeOffset = uTime * 0.05; float sinY = sin((uv.y + 0.0000) * waveFreq * (1. - uAmount) * 2. + timeOffset); float rogue = smoothstep(0., 2., sinY - 0.5) * 0.2 * 0.2000; float sinWaveX = sin(uv.y * waveFreq + uTime); float sinWaveY = sin(uv.x * waveFreq + uTime); uv.x += sinWaveX * waveAmp + rogue; uv.y += sinWaveY * waveAmp; float waveX = sinWaveX * waveAmp + rogue * chromab * 0.2;uv = clamp(uv, vec2(0.005), vec2(0.995));vec4 color = texture(uTexture, uv);vec2 redOffset = vec2( clamp(uv.x + (glitchModX * -offX * chromab - waveX), 0.005, 0.995), clamp(uv.y + (glitchModX * -offY * chromab), 0.005, 0.995) ); vec2 blueOffset = vec2( clamp(uv.x + (glitchModX * offX * chromab + waveX), 0.005, 0.995), clamp(uv.y + (glitchModX * offY * chromab), 0.005, 0.995) );color.r = texture(uTexture, redOffset).r; color.b = texture(uTexture, blueOffset).b; fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect6"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"vignette","usesPingPong":false,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float; in vec3 vVertexPosition; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform vec2 uResolution;out vec4 fragColor; mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); } void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); float luma = dot(color.rgb, vec3(0.299, 0.587, 0.114)); float displacement = (luma - 0.5) * 0.0000 * 0.5; vec2 aspectRatio = vec2(uResolution.x/uResolution.y, 1.0); vec2 skew = vec2(0.5000, 1.0 - 0.5000); float halfRadius = 0.5000 * 0.5; float innerEdge = halfRadius - 1.0000 * halfRadius * 0.5; float outerEdge = halfRadius + 1.0000 * halfRadius * 0.5; vec2 pos = vec2(0.5, 0.5); const float TWO_PI = 6.28318530718; vec2 scaledUV = uv * aspectRatio * rot(0.0000 * TWO_PI) * skew; vec2 scaledPos = pos * aspectRatio * rot(0.0000 * TWO_PI) * skew; float radius = distance(scaledUV, scaledPos); float falloff = smoothstep(innerEdge + displacement, outerEdge + displacement, radius); vec3 finalColor;finalColor = mix(color.rgb, mix(color.rgb, vec3(0, 0, 0), 1.0000), falloff); color = mix(color * (1.-falloff), vec4(finalColor * color.a, color.a), 1.0000); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect7"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"stretch","usesPingPong":false,"amount":0,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"parentLayer":"d139944c-f7db-4405-a658-7991ccd77af3","animating":false,"isMask":0,"states":{"appear":[{"local":{"pendingChanges":{},"changeDebouncer":null,"dragSession":null},"type":"appear","id":"c6e165df-d2d6-4f85-a212-0a5284bf9a40","prop":"amount","transition":{"delay":0,"duration":1000,"ease":"easeInOutQuart"},"complete":false,"progress":0,"value":1,"endValue":0,"initialized":false,"breakpoints":[],"loop":"none","loopDelay":0,"uniformData":{"type":"1f","name":"uAmount"}}],"scroll":[],"hover":[]},"compiledFragmentShaders":["#version 300 es\nprecision mediump float; in vec3 vVertexPosition; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform float uAmount; uniform vec2 uMousePos; uniform vec2 uResolution;out vec4 fragColor;vec2 rotate(vec2 v, float angle) { float c = cos(angle); float s = sin(angle); return vec2(v.x * c - v.y * s, v.x * s + v.y * c); }vec3 chromatic_aberration(vec3 color, vec2 uv, float amount) { vec2 offset = normalize(vTextureCoord - 0.5) * amount / vec2(uResolution.x/uResolution.y, 1); vec4 left = texture(uTexture, uv - offset); vec4 right = texture(uTexture, uv + offset);color.r = left.r; color.b = right.b;return color; }void main() { vec2 uv = vTextureCoord; float angle = (0.5000 - 0.25) * -6.28318530718; float stretchX = vec2(1, 1).x * 4. * uAmount; float stretchY = vec2(1, 1).y * 4. * uAmount;vec2 pos = vec2(0.5, 1.27) + (uMousePos - 0.5) * 0.0000; vec2 offset = uv - pos; vec2 rotatedOffset = rotate(offset, -angle); vec2 stretchedOffset = rotatedOffset; if (2 == 1) { if (rotatedOffset.x > 0.0) { float stretchIntensity = rotatedOffset.x; stretchedOffset.x = rotatedOffset.x / (1.0 + stretchX * stretchIntensity); stretchedOffset.y = rotatedOffset.y / (1.0 + stretchY * stretchIntensity * stretchIntensity); } } else if (2 == 2) { float stretchIntensity = abs(rotatedOffset.x); stretchedOffset.x = sign(rotatedOffset.x) * stretchIntensity / (1.0 + stretchX * stretchIntensity); stretchedOffset.y = rotatedOffset.y / (1.0 + stretchY * stretchIntensity * stretchIntensity); } vec2 finalOffset = rotate(stretchedOffset, angle); vec2 st = pos + finalOffset; vec4 color = texture(uTexture, st);color.rgb = chromatic_aberration(color.rgb, st, length(st - uv) * 0.05 * 1.0000); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect8"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"reflectiveSurface","usesPingPong":false,"texture":false,"animating":false,"mouseMomentum":0,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uResolution;out vec4 fragColor;const float PI2 = 6.28318530718;vec2 rotatePoint(vec2 point, vec2 center, float angle) { vec2 translated = point - center; float cosAngle = cos(angle); float sinAngle = sin(angle); vec2 rotated = vec2( translated.x * cosAngle - translated.y * sinAngle, translated.x * sinAngle + translated.y * cosAngle ); return rotated + center; }vec2 getRotatedCoord(vec2 coord) { float aspectRatio = uResolution.x / uResolution.y; vec2 correctedCoord = coord; correctedCoord.x *= aspectRatio; vec2 correctedPos = vec2(0.48186215235792024, 0.2690447400241839); correctedPos.x *= aspectRatio; vec2 rotatedCorrected = rotatePoint(correctedCoord, correctedPos, 0.0000 * PI2); vec2 result = rotatedCorrected; result.x /= aspectRatio; return result; }vec2 getInverseRotatedCoord(vec2 coord) { float aspectRatio = uResolution.x / uResolution.y; vec2 correctedCoord = coord; correctedCoord.x *= aspectRatio; vec2 correctedPos = vec2(0.48186215235792024, 0.2690447400241839); correctedPos.x *= aspectRatio; vec2 rotatedCorrected = rotatePoint(correctedCoord, correctedPos, 0.0000 * -1. * PI2); vec2 result = rotatedCorrected; result.x /= aspectRatio; return result; }const int kernelSize = 36;float getGaussianWeight(int index) { switch(index) { case 0: return 0.00094768; case 1: return 0.00151965; case 2: return 0.00237008; case 3: return 0.00359517; case 4: return 0.0053041; case 5: return 0.00761097; case 6: return 0.01062197; case 7: return 0.01441804; case 8: return 0.01903459; case 9: return 0.0244409; case 10: return 0.03052299; case 11: return 0.03707432; case 12: return 0.04379813; case 13: return 0.05032389; case 14: return 0.05623791; case 15: return 0.06112521; case 16: return 0.06461716; case 17: return 0.06643724; case 18: return 0.06643724; case 19: return 0.06461716; case 20: return 0.06112521; case 21: return 0.05623791; case 22: return 0.05032389; case 23: return 0.04379813; case 24: return 0.03707432; case 25: return 0.03052299; case 26: return 0.0244409; case 27: return 0.01903459; case 28: return 0.01441804; case 29: return 0.01062197; case 30: return 0.00761097; case 31: return 0.0053041; case 32: return 0.00359517; case 33: return 0.00237008; case 34: return 0.00151965; case 35: return 0.00094768; default: return 0.0; } }vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0); float weightSum = 0.0;vec2 rotatedUV = getRotatedCoord(uv); vec2 rotatedPos = vec2(0.48186215235792024, 0.2690447400241839); float y = max(0., distance(rotatedUV.y, rotatedPos.y));float radius = 8.;float amount = max(0.25, (0.5000 + 0.1) * radius * y * 4.); float aspectRatio = uResolution.x/uResolution.y;direction.x /= aspectRatio;color += texture(tex, uv) * getGaussianWeight(0); for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount; color += texture(tex, uv + vec2(x/1000.) * direction) * getGaussianWeight(i); } return color; }vec4 blurPass(vec2 uv) { float aspectRatio = uResolution.x / uResolution.y; vec2 direction = vec2(0);if (0 % 2 == 1) { direction = vec2(1,0); direction.x *= (1.-0.5000); } else { direction = vec2(0,1); }vec2 rotatedUV = getRotatedCoord(uv); vec2 rotatedPos = vec2(0.48186215235792024, 0.2690447400241839); rotatedUV = mix(rotatedUV, (rotatedUV + vec2(0., rotatedPos.y)) * vec2(1., 0.5), 0.5000 - 0.5); uv = getInverseRotatedCoord(rotatedUV);return GaussianBlur(uTexture, uv, direction); }vec4 getColor(vec2 uv) { return blurPass(uv); }void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); fragColor = color;}","#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uResolution;out vec4 fragColor;const float PI2 = 6.28318530718;vec2 rotatePoint(vec2 point, vec2 center, float angle) { vec2 translated = point - center; float cosAngle = cos(angle); float sinAngle = sin(angle); vec2 rotated = vec2( translated.x * cosAngle - translated.y * sinAngle, translated.x * sinAngle + translated.y * cosAngle ); return rotated + center; }vec2 getRotatedCoord(vec2 coord) { float aspectRatio = uResolution.x / uResolution.y; vec2 correctedCoord = coord; correctedCoord.x *= aspectRatio; vec2 correctedPos = vec2(0.48186215235792024, 0.2690447400241839); correctedPos.x *= aspectRatio; vec2 rotatedCorrected = rotatePoint(correctedCoord, correctedPos, 0.0000 * PI2); vec2 result = rotatedCorrected; result.x /= aspectRatio; return result; }vec2 getInverseRotatedCoord(vec2 coord) { float aspectRatio = uResolution.x / uResolution.y; vec2 correctedCoord = coord; correctedCoord.x *= aspectRatio; vec2 correctedPos = vec2(0.48186215235792024, 0.2690447400241839); correctedPos.x *= aspectRatio; vec2 rotatedCorrected = rotatePoint(correctedCoord, correctedPos, 0.0000 * -1. * PI2); vec2 result = rotatedCorrected; result.x /= aspectRatio; return result; }const int kernelSize = 36;float getGaussianWeight(int index) { switch(index) { case 0: return 0.00094768; case 1: return 0.00151965; case 2: return 0.00237008; case 3: return 0.00359517; case 4: return 0.0053041; case 5: return 0.00761097; case 6: return 0.01062197; case 7: return 0.01441804; case 8: return 0.01903459; case 9: return 0.0244409; case 10: return 0.03052299; case 11: return 0.03707432; case 12: return 0.04379813; case 13: return 0.05032389; case 14: return 0.05623791; case 15: return 0.06112521; case 16: return 0.06461716; case 17: return 0.06643724; case 18: return 0.06643724; case 19: return 0.06461716; case 20: return 0.06112521; case 21: return 0.05623791; case 22: return 0.05032389; case 23: return 0.04379813; case 24: return 0.03707432; case 25: return 0.03052299; case 26: return 0.0244409; case 27: return 0.01903459; case 28: return 0.01441804; case 29: return 0.01062197; case 30: return 0.00761097; case 31: return 0.0053041; case 32: return 0.00359517; case 33: return 0.00237008; case 34: return 0.00151965; case 35: return 0.00094768; default: return 0.0; } }vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0); float weightSum = 0.0;vec2 rotatedUV = getRotatedCoord(uv); vec2 rotatedPos = vec2(0.48186215235792024, 0.2690447400241839); float y = max(0., distance(rotatedUV.y, rotatedPos.y));float radius = 8.;float amount = max(0.25, (0.5000 + 0.1) * radius * y * 4.); float aspectRatio = uResolution.x/uResolution.y;direction.x /= aspectRatio;color += texture(tex, uv) * getGaussianWeight(0); for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount; color += texture(tex, uv + vec2(x/1000.) * direction) * getGaussianWeight(i); } return color; }vec4 blurPass(vec2 uv) { float aspectRatio = uResolution.x / uResolution.y; vec2 direction = vec2(0);if (1 % 2 == 1) { direction = vec2(1,0); direction.x *= (1.-0.5000); } else { direction = vec2(0,1); }vec2 rotatedUV = getRotatedCoord(uv); vec2 rotatedPos = vec2(0.48186215235792024, 0.2690447400241839); rotatedUV = mix(rotatedUV, (rotatedUV + vec2(0., rotatedPos.y)) * vec2(1., 0.5), 0.5000 - 0.5); uv = getInverseRotatedCoord(rotatedUV);return GaussianBlur(uTexture, uv, direction); }vec4 getColor(vec2 uv) { return blurPass(uv); }void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); fragColor = color;}","#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture;uniform vec2 uResolution;uvec2 pcg2d(uvec2 v) { v = v * 1664525u + 1013904223u; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; v ^= v >> 16; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; return v; }float randFibo(vec2 p) { uvec2 v = floatBitsToUint(p); v = pcg2d(v); uint r = v.x ^ v.y; return float(r) / float(0xffffffffu); }out vec4 fragColor;const float PI2 = 6.28318530718;vec2 rotatePoint(vec2 point, vec2 center, float angle) { vec2 translated = point - center; float cosAngle = cos(angle); float sinAngle = sin(angle); vec2 rotated = vec2( translated.x * cosAngle - translated.y * sinAngle, translated.x * sinAngle + translated.y * cosAngle ); return rotated + center; }vec2 getRotatedCoord(vec2 coord) { float aspectRatio = uResolution.x / uResolution.y; vec2 correctedCoord = coord; correctedCoord.x *= aspectRatio; vec2 correctedPos = vec2(0.48186215235792024, 0.2690447400241839); correctedPos.x *= aspectRatio; vec2 rotatedCorrected = rotatePoint(correctedCoord, correctedPos, 0.0000 * PI2); vec2 result = rotatedCorrected; result.x /= aspectRatio; return result; }vec2 getInverseRotatedCoord(vec2 coord) { float aspectRatio = uResolution.x / uResolution.y; vec2 correctedCoord = coord; correctedCoord.x *= aspectRatio; vec2 correctedPos = vec2(0.48186215235792024, 0.2690447400241839); correctedPos.x *= aspectRatio; vec2 rotatedCorrected = rotatePoint(correctedCoord, correctedPos, 0.0000 * -1. * PI2); vec2 result = rotatedCorrected; result.x /= aspectRatio; return result; }const int kernelSize = 36;float getGaussianWeight(int index) { switch(index) { case 0: return 0.00094768; case 1: return 0.00151965; case 2: return 0.00237008; case 3: return 0.00359517; case 4: return 0.0053041; case 5: return 0.00761097; case 6: return 0.01062197; case 7: return 0.01441804; case 8: return 0.01903459; case 9: return 0.0244409; case 10: return 0.03052299; case 11: return 0.03707432; case 12: return 0.04379813; case 13: return 0.05032389; case 14: return 0.05623791; case 15: return 0.06112521; case 16: return 0.06461716; case 17: return 0.06643724; case 18: return 0.06643724; case 19: return 0.06461716; case 20: return 0.06112521; case 21: return 0.05623791; case 22: return 0.05032389; case 23: return 0.04379813; case 24: return 0.03707432; case 25: return 0.03052299; case 26: return 0.0244409; case 27: return 0.01903459; case 28: return 0.01441804; case 29: return 0.01062197; case 30: return 0.00761097; case 31: return 0.0053041; case 32: return 0.00359517; case 33: return 0.00237008; case 34: return 0.00151965; case 35: return 0.00094768; default: return 0.0; } }vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0); float weightSum = 0.0;vec2 rotatedUV = getRotatedCoord(uv); vec2 rotatedPos = vec2(0.48186215235792024, 0.2690447400241839); float y = max(0., distance(rotatedUV.y, rotatedPos.y));float radius = 8.;float amount = max(0.25, (0.5000 + 0.1) * radius * y * 4.); float aspectRatio = uResolution.x/uResolution.y;direction.x /= aspectRatio;color += texture(tex, uv) * getGaussianWeight(0); for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount; color += texture(tex, uv + vec2(x/1000.) * direction) * getGaussianWeight(i); } return color; }vec4 blurPass(vec2 uv) { float aspectRatio = uResolution.x / uResolution.y; vec2 direction = vec2(0);if (2 % 2 == 1) { direction = vec2(1,0); direction.x *= (1.-0.5000); } else { direction = vec2(0,1); }vec2 rotatedUV = getRotatedCoord(uv); vec2 rotatedPos = vec2(0.48186215235792024, 0.2690447400241839); rotatedUV = mix(rotatedUV, (rotatedUV + vec2(0., rotatedPos.y)) * vec2(1., 0.5), 0.5000 - 0.5); uv = getInverseRotatedCoord(rotatedUV);return GaussianBlur(uTexture, uv, direction); }vec4 reflectAndMix(vec4 originalColor, vec4 blurredColor, float yPos) { vec2 rotatedCoord = getRotatedCoord(vTextureCoord); float reflectedY = yPos - (rotatedCoord.y - yPos); reflectedY = clamp(reflectedY, 0., 1.);vec2 rotatedReflectedCoord = vec2(rotatedCoord.x, reflectedY); vec2 reflectedCoord = getInverseRotatedCoord(rotatedReflectedCoord); reflectedCoord = clamp(reflectedCoord, 0., 1.);vec4 reflectedColor = texture(uTexture, reflectedCoord);reflectedColor.rgb = mix(vec3(0, 0, 0), reflectedColor.rgb, 0.5000);float dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0; reflectedColor.rgb += dither;return mix(originalColor, reflectedColor, step(rotatedCoord.y, yPos)); }vec4 compositePass(vec2 uv) { vec4 bg = texture(uBgTexture, uv); vec4 blur = blurPass(uv); return reflectAndMix(bg, blur, vec2(0.48186215235792024, 0.2690447400241839).y); }vec4 getColor(vec2 uv) { return compositePass(uv); }void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"downSample":0.25,"depth":false,"uniforms":{},"isBackground":false,"passes":[{"prop":"pass","value":1,"downSample":0.25},{"prop":"pass","value":2,"includeBg":0.5}]},"id":"effect9"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"mouse","usesPingPong":true,"mouseMomentum":0,"texture":false,"parentLayer":"4882a347-f3b1-4b4c-aa60-42d54e84913e","animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uTexture; uniform sampler2D uPingPongTexture; uniform vec2 uResolution;const float PI = 3.1415926; const float ITERATIONS = 24.0;out vec4 fragColor;vec3 rgb2hsv(vec3 c) { vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0); vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g)); vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));float d = q.x - min(q.w, q.y); float e = 1.0e-10; return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x); }vec3 chromatic_aberration(vec3 color, vec2 uv, vec2 offset) { vec4 left = texture(uTexture, uv - offset); vec4 right = texture(uTexture, uv + offset);color.r = left.r; color.b = right.b;return color; }vec2 angleToDir(float angle) { float rad = angle * 2.0 * PI; return vec2(cos(rad), sin(rad)); }vec4 defaultTrail(vec2 uv, vec2 mouseDir) { vec4 color = vec4(0); vec2 distorted = mouseDir * 0.4; uv -= distorted; color = texture(uTexture, uv); color.rgb = chromatic_aberration(color.rgb, uv, distorted * 1.0000 * 0.12); return color; }vec4 getTrailColor(vec2 uv, vec2 mouseDir, float strength, float aspectRatio) { vec4 color = vec4(0);return defaultTrail(uv, mouseDir); }void main() { vec2 uv = vTextureCoord; vec2 pingpongUv = uv; float aspectRatio = uResolution.x / uResolution.y;vec3 mouseRgb = texture(uPingPongTexture, pingpongUv).rgb; vec3 mouseTrail = rgb2hsv(mouseRgb);float angle = mouseTrail.x; float strength = mouseTrail.z * (0.2900 * 2.0); vec2 direction = angleToDir(angle); vec2 mouseDir = direction * strength;vec4 color = getTrailColor(uv, mouseDir, abs(strength), aspectRatio);fragColor = color; }","#version 300 es\nprecision highp float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uPingPongTexture; uniform vec2 uPreviousMousePos; uniform float uTime;uniform vec2 uMousePos; uniform vec2 uResolution;const float PI = 3.1415926; const float TWOPI = 6.2831852;out vec4 fragColor;vec3 hsv2rgb(vec3 c) { vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0); vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www); return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y); }mat2 rot(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }vec2 liquify(vec2 st, float angle) { float aspectRatio = uResolution.x / uResolution.y; st.x *= aspectRatio; st = st * rot(angle * TWOPI); float amplitude = 0.003; for (float i = 1.0; i <= 5.0; i++) { st = st * rot(i / 5.0 * PI * 2.0); st += vec2( amplitude * cos(i * 5.0 * st.y + uTime * 0.02), amplitude * sin(i * 5.0 * st.x + uTime * 0.02) ); } st = st * rot(-angle * TWOPI); st.x /= aspectRatio; return st; }void main() { float aspectRatio = uResolution.x / uResolution.y; vec2 aspectVec = vec2(aspectRatio, 1.0); vec2 uv = vTextureCoord; vec2 correctedUv = uv * aspectVec;vec2 dir = (uMousePos - uPreviousMousePos) * aspectVec; float dist = length(dir); if (dist > 0.0) { dir = dir / dist; } else { dir = vec2(1.0, 0.0); }float rad = 0.2200 * 0.4 * mix(aspectRatio, 1.0, 0.5); float angle = atan(dir.y, dir.x); if (angle < 0.0) angle += TWOPI;uv = mix(uv, liquify(uv, smoothstep(0.0, 1.0, angle)), 1.0000);float t = dist > 0.0 ? clamp(dot(correctedUv - uPreviousMousePos * aspectVec, dir) / dist, 0.0, 1.0) : 0.0; vec2 closestPoint = mix(uPreviousMousePos, uMousePos, t) * aspectVec; float distanceToLine = distance(correctedUv, closestPoint);float s = smoothstep(rad, rad * 0.0000, distanceToLine);s = s * s;vec3 color = vec3(angle / TWOPI, 1.0, 1.0); vec3 mouseColor = hsv2rgb(color);vec2 sampleUv = mix(uv, uv / (1.0 + 1.0000 * 0.03) + 1.0000 * 0.015, 1.0000); vec3 lastFrameColor = texture(uPingPongTexture, sampleUv).rgb; lastFrameColor = pow(lastFrameColor, vec3(2.2)); mouseColor = pow(mouseColor, vec3(2.2)); float intensity = min(0.7, dist * 10.0) * s * 0.4; vec3 draw = mix(lastFrameColor, mouseColor, intensity); draw *= pow(0.4600, 0.2); draw = pow(draw, vec3(1.0/2.2)); fragColor = vec4(draw, 1.0); }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }","#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect10"},{"breakpoints":[{"max":null,"name":"Desktop","props":{"width":800,"fontSize":99,"fontStyle":"regular"},"min":992},{"props":{"width":800,"fontStyle":"700","fontSize":36},"min":0,"name":"Mobile","max":575}],"visible":true,"locked":false,"aspectRatio":1,"layerName":"DootLord","userDownsample":1,"isElement":true,"opacity":0,"effects":["b0d6a7c0-0f59-4363-a0ef-823521b70d4b","a8a28893-34c3-4d7f-940f-69a1cd8a81d6","0de16c7f-fc28-4d08-a2b9-549ac7db0e13","cf58334b-7b55-4307-a9a3-3c08257498f7","b7552748-e750-4446-9fa5-ab54d4a580f5"],"displace":0,"trackMouse":0.01,"anchorPoint":"center","mouseMomentum":0.5,"blendMode":"NORMAL","bgDisplace":1,"mask":0,"maskBackground":{"type":"Vec3","_x":0,"_y":0,"_z":0},"maskAlpha":0,"maskDepth":0,"dispersion":0,"axisTilt":0,"states":{"appear":[{"local":{"pendingChanges":{},"changeDebouncer":null,"dragSession":null},"type":"appear","id":"c78a3158-4e67-473d-9f17-784d78497fe5","prop":"opacity","transition":{"ease":"easeInOutQuart","delay":500,"duration":1000},"complete":false,"progress":0,"value":0,"endValue":1,"initialized":false,"breakpoints":[],"loop":"none","loopDelay":0,"uniformData":{"type":"1f","name":"uOpacity"}},{"local":{"pendingChanges":{},"changeDebouncer":null,"dragSession":null},"type":"appear","id":"15f669ff-e334-4967-972f-36f6672f83be","prop":"letterSpacing","transition":{"ease":"easeInOutQuart","delay":500,"duration":2000},"complete":false,"progress":0,"value":0,"endValue":15,"initialized":false,"breakpoints":[],"loop":"none","loopDelay":0}],"scroll":[],"hover":[]},"layerType":"text","justCreated":false,"isSafari":false,"width":800,"widthMode":"fixed","height":60,"heightMode":"fixed","left":0.5,"leftMode":"relative","top":0.8563333333333333,"topMode":"relative","rotation":0,"trackAxes":"xy","fontSize":99,"lineHeight":60,"letterSpacing":0,"fontFamily":"Inria Serif","fontStyle":"regular","fontWeight":"400","textAlign":"center","textContent":"DootLord","fill":["#CEFFDD"],"gradientAngle":0,"gradientType":"linear","fontSizeMode":"fixed","noTextAsHtml":false,"fontCSS":{"src":"https://assets.unicorn.studio/fonts/google_fonts/fC1lPYxPY3rXxEndZJAzN0SsfSzNr0Ck.ttf","family":"Inria Serif"},"compiledFragmentShaders":["#version 300 es\nprecision highp float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uBgTexture; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform float uOpacity; uniform int uSampleBg;out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.0100);uv = uv - pos;vec4 color = texture(uTexture, uv); vec4 background = vec4(0);if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); }color = mix(background, color / max(color.a, 0.0001), color.a * uOpacity);fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision highp float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"uniforms":{}},"id":"text","windowWidth":1440},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"twod_sdf","usesPingPong":false,"texture":false,"speed":0.25,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float; in vec3 vVertexPosition; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution;out vec4 fragColor;const float PI = 3.14159265359;mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }float sdBox(vec2 p, vec2 b) { vec2 q = abs(p)-b; return length(max(q,0.0)) + min(max(q.x,q.y),0.0); }float sdX(vec2 p, float w) { p = abs(p); float d1 = sdBox(rot(PI/4.0) * p, vec2(w, w * 0.3)); float d2 = sdBox(rot(-PI/4.0) * p, vec2(w, w * 0.3)); return min(d1, d2); }float getDistance(vec2 uv) { return sdX(uv, 0.4); }float getDist(vec2 uv) { float sd = getDistance(uv);vec2 aspect = vec2(uResolution.x/uResolution.y, 1.0); vec2 mousePos = (uMousePos * aspect); float mouseDistance = length(vTextureCoord * aspect - mousePos); float falloff = smoothstep(0.0, 0.8, mouseDistance); float asd = 2.0;asd = -asd;float md = mix(0.02/falloff, 0.1/falloff, -asd * sd); md = md * 1.5 * 0.0000; md = min(-md, 0.0); sd -= md;return sd; }vec4 refrakt(float sd, vec2 st, vec4 bg) {vec2 offset = mix(vec2(0), normalize(st)/sd, length(st));vec4 r = vec4(0,0,0,1); float rdisp = mix(0.01, 0.008, 0.5000); float gdisp = mix(0.01, 0.01, 0.5000); float bdisp = mix(0.01, 0.012, 0.5000); vec2 uv = (vTextureCoord - 0.5) / mix(1., 4., 0.0000) + 0.5; r.r = texture(uTexture, uv + offset * (0.7500 - 0.5) * rdisp).r; r.g = texture(uTexture, uv + offset * (0.7500 - 0.5) * gdisp).g; r.b = texture(uTexture, uv + offset * (0.7500 - 0.5) * bdisp).b; float opacity = ceil(-sd); float smoothness = 0.0025; opacity = smoothstep(0., smoothness, -sd);vec4 background = vec4(0); return mix(background, r + vec4(vec3(0.4, 0.1, 1)/(-sd * 50.), 1.) * 0.0000, opacity); }vec4 getEffect(vec2 st, vec4 bg) { float eps = 0.0005;float sd = getDist(st); float sd1 = getDist(st + vec2(eps, 0.0)); float sd2 = getDist(st - vec2(eps, 0.0)); float sd3 = getDist(st + vec2(0.0, eps)); float sd4 = getDist(st - vec2(0.0, eps));vec4 r = refrakt(sd, st, bg); vec4 r1 = refrakt(sd1, st + vec2(eps, 0.0), bg); vec4 r2 = refrakt(sd2, st - vec2(eps, 0.0), bg); vec4 r3 = refrakt(sd3, st + vec2(0.0, eps), bg); vec4 r4 = refrakt(sd4, st - vec2(0.0, eps), bg); r = (r + r1 + r2 + r3 + r4) * 0.2; return r; } void main() { vec2 uv = vTextureCoord; vec4 bg = texture(uTexture, uv); vec4 color = vec4(1); vec2 aspect = vec2(uResolution.x/uResolution.y, 1.0); vec2 mousePos = mix(vec2(0), uMousePos - 0.5, 0.0000); vec2 st = uv - (vec2(0.33675937122128174, -0.07678355501813772) + mousePos); st *= aspect; st *= 1./(6.6400 + 0.2); st *= rot(0.0000 * 2.0 * PI); color = getEffect(st, bg); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect11"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"godrays","usesPingPong":false,"pos":{"type":"Vec2","_x":0.5007557436517533,"_y":0.9824667472793228},"trackMouse":0.11,"trackAxes":"xy","mouseMomentum":0,"texture":false,"parentLayer":"b0d6a7c0-0f59-4363-a0ef-823521b70d4b","animating":false,"isMask":0,"states":{"appear":[{"local":{"pendingChanges":{},"changeDebouncer":null,"dragSession":null},"type":"appear","id":"b331ebf9-c692-4d45-9cca-ccdb9890b0dc","prop":"pos","transition":{"delay":1000,"duration":500,"ease":"easeInOutQuart"},"complete":false,"progress":0,"value":{"type":"Vec2","_x":0.5007557436517533,"_y":0.9824667472793228},"endValue":{"type":"Vec2","_x":0.5007557436517533,"_y":0.462},"initialized":false,"breakpoints":[],"loop":"none","loopDelay":0,"uniformData":{"type":"2f","name":"uPos"}}],"scroll":[],"hover":[]},"compiledFragmentShaders":["#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;const float MAX_ITERATIONS = 64.; const float PI2 = 6.28318530718; const float EPSILON = 0.0001; const float stepFactor = 0.0098;vec4 getBrightAreas(vec2 uv) { vec4 color = texture(uTexture, uv); float lum = dot(color.rgb, vec3(0.299, 0.587, 0.114)); color = color * smoothstep(0.7500 - 0.1, 0.7500, lum); return color; }vec4 getColor(vec2 uv) { return getBrightAreas(uv); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); if(0 == 2) { fragColor = color;} else { fragColor = color; } }","#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform vec2 uPos;uniform vec2 uMousePos;uvec2 pcg2d(uvec2 v) { v = v * 1664525u + 1013904223u; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; v ^= v >> 16; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; return v; }float randFibo(vec2 p) { uvec2 v = floatBitsToUint(p); v = pcg2d(v); uint r = v.x ^ v.y; return float(r) / float(0xffffffffu); }const float MAX_ITERATIONS = 64.; const float PI2 = 6.28318530718; const float EPSILON = 0.0001; const float stepFactor = 0.0098;vec4 godRays(vec2 st, float decay) { vec3 color = vec3(0); float offset = (0.25 + min(1., 0.6500)) * stepFactor; vec2 pos = uPos - mix(vec2(0), (vec2(1. - uMousePos.x, 1. - uMousePos.y) - 0.5), 0.1100); float weight = 1.0; float bnoz = randFibo(st) * 0.6500; float distanceInfo = 0.0; vec2 marchPos = st;for (float i = 0.0; i < MAX_ITERATIONS; i += 4.0) { for (float j = 0.0; j < 4.0; j++) { float bno = randFibo(st + vec2(i/MAX_ITERATIONS + j/4.0)) * 0.6500; vec2 offbno = vec2(cos(bno) - 0.5, sin(bno) - 0.5); float x = min(0.999, (i + j) * offset) + bnoz * 0.02; float y = min(0.999, (i + j)); marchPos = st * (1.0 - x) + vec2(x * 0.5) + (pos - 0.5) * x + offbno * 0.02 * 0.4000 * x; color += texture(uTexture, marchPos).rgb * weight; distanceInfo += y * weight; weight *= decay; if(weight < 0.01) break; } } return vec4(color / MAX_ITERATIONS, distance(st, marchPos)); }vec4 getGodRays(vec2 uv) { if(0.9600 == 0.) { return vec4(0); } vec4 rays = godRays(uv, 0.972); rays.rgb *= vec3(0, 0.9803921568627451, 0.9333333333333333); vec4 color; color.rgb = rays.rgb; color.a = rays.a; return color; }vec4 getColor(vec2 uv) { return getGodRays(uv); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); if(1 == 2) { fragColor = color;} else { fragColor = color; } }","#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture; uniform sampler2D uBlueNoise;uniform vec2 uResolution;const float MAX_ITERATIONS = 64.; const float PI2 = 6.28318530718; const float EPSILON = 0.0001; const float stepFactor = 0.0098;float luma(vec4 color) { return dot(color.rgb, vec3(0.299, 0.587, 0.114)); }float getBlueNoiseOffset(vec2 st) { ivec2 texSize = ivec2(512, 512); vec4 blueNoise = texelFetch(uBlueNoise, ivec2(fract(st * (uResolution)/vec2(texSize) * vec2(texSize.x/texSize.y, 1.0)) * vec2(texSize)) % texSize, 0); return mod((blueNoise.r - 0.5) * PI2, PI2); }vec4 composite(vec2 uv) { vec4 godrays = texture(uTexture, uv); float distanceInfo = godrays.a; float luminance = luma(godrays); float blueNoise = getBlueNoiseOffset(uv) - 0.5; vec2 circNoise = vec2(cos(blueNoise), sin(blueNoise)); float brightnessScale = (1. - (luminance + 0.25)); vec2 offset = circNoise * 0.05 * pow(brightnessScale, 3.) * distanceInfo * 2.; vec4 color = texture(uTexture, uv + offset); vec4 bg = texture(uBgTexture, uv);color.rgb = bg.rgb + (color.rgb * 2.9 * 0.9600 + blueNoise * 0.001); color.a = bg.a + color.r; return color; }vec4 getColor(vec2 uv) { return composite(uv); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); if(2 == 2) { fragColor = color;} else { fragColor = color; } }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false,"passes":[{"prop":"pass","value":1,"downSample":0.5},{"prop":"pass","value":2,"includeBg":true}],"texture":{"src":"https://assets.unicorn.studio/media/blue_noise_med.png","sampler":"uBlueNoise"}},"id":"effect12"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"guilloche","usesPingPong":false,"speed":0.25,"texture":false,"parentLayer":"a8a28893-34c3-4d7f-940f-69a1cd8a81d6","animating":true,"mouseMomentum":0,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime;uniform vec2 uResolution;const float PI = 3.14159265359; mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }float getWaveLine(vec2 uv, float intensity) { float lineFreq = 150.0 * 0.7500; float waveAmplitude = 0.04 * 0.5000; float waveFreq = 8.0 * 0.5000; float sineOffset = waveAmplitude * sin((uv.x + uTime*0.005) * waveFreq * 2.0 * 3.14159); uv.y += sineOffset; float lineWidth = mix(0., 1., intensity);float linePosition = fract(uv.y * lineFreq); float gradient = smoothstep(0., lineWidth, linePosition) - smoothstep(1.0 - lineWidth, 1.0, linePosition);return smoothstep(0., lineWidth*1.5, gradient*gradient); }float getZigZagLine(vec2 uv, float lineWidth) { float lineFreq = 150.0 * 0.7500; float waveAmplitude = 0.8 * 0.5000; float flipInterval = 0.2 * (1. - 0.5000 + 0.001); float flip = mod(floor(uv.x / flipInterval), 2.0); uv.x -= flipInterval * 0.5 + floor(uv.x / flipInterval) * flipInterval + uTime*0.005; uv = (uv * rot(waveAmplitude * (flip * 2.0 - 1.0))); uv.x += flipInterval * 0.5;float linePosition = fract(uv.y * lineFreq);float gradient = smoothstep(0.0, lineWidth, linePosition) - smoothstep(1.0 - lineWidth, 1.0, linePosition); return smoothstep(0., lineWidth*1.5, gradient*gradient); }float getGuillocheLine(vec2 uv, float lineWidth) { float lineFreq = 150.0 * 0.7500; float waveAmplitude = 0.04 * 0.5000; float waveFreq = 8.0 * 0.5000; uv.x += waveAmplitude * sin((uv.y + uTime*0.005) * waveFreq * 2.0 * 3.14159);float linePosition = fract(uv.x * lineFreq);float gradient = smoothstep(0.0, lineWidth, linePosition) - smoothstep(1.0 - lineWidth, 1.0, linePosition); return smoothstep(0., 1., gradient*gradient); }float getGuillocheFull(vec2 uv, float lineWidth) { float mult = getGuillocheLine(uv * rot(0.25 * 2. * PI), lineWidth) * 0.75; float add = getGuillocheLine(uv * rot(0.25 * 2. * PI), lineWidth) + getGuillocheLine(uv, lineWidth); return mix(add, mult, smoothstep(0., 1., lineWidth)); }vec3 photoshop_desaturate(vec3 color) { float bw = (min(color.r, min(color.g, color.b)) + max(color.r, max(color.g, color.b))) * 0.5; return vec3(bw); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord;vec4 color = texture(uTexture, uv); vec3 linographed = vec3(0);float red = 1.-color.r; float green = 1.-color.g; float blue = 1.-color.b;vec2 st = rot(0.0000 * -1. * 2. * PI) * ((uv * vec2(uResolution.x/uResolution.y, 1.)) - vec2(0.5, 0.5)); if(0 == 0) { linographed = vec3( getGuillocheFull(st, red), getGuillocheFull(st, green), getGuillocheFull(st, blue) ); } if(0 == 1) { linographed = vec3( getWaveLine(st, red), getWaveLine(st, green), getWaveLine(st, blue) ); } if(0 == 2) { linographed = vec3( getZigZagLine(st, red), getZigZagLine(st, green), getZigZagLine(st, blue) ); }color.rgb = mix(color.rgb, linographed, 1.0000); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect13"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"godrays","usesPingPong":false,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"parentLayer":"0de16c7f-fc28-4d08-a2b9-549ac7db0e13","animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;const float MAX_ITERATIONS = 64.; const float PI2 = 6.28318530718; const float EPSILON = 0.0001; const float stepFactor = 0.0098;vec4 getBrightAreas(vec2 uv) { vec4 color = texture(uTexture, uv); float lum = dot(color.rgb, vec3(0.299, 0.587, 0.114)); color = color * smoothstep(0.5000 - 0.1, 0.5000, lum); return color; }vec4 getColor(vec2 uv) { return getBrightAreas(uv); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); if(0 == 2) { fragColor = color;} else { fragColor = color; } }","#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uMousePos;uvec2 pcg2d(uvec2 v) { v = v * 1664525u + 1013904223u; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; v ^= v >> 16; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; return v; }float randFibo(vec2 p) { uvec2 v = floatBitsToUint(p); v = pcg2d(v); uint r = v.x ^ v.y; return float(r) / float(0xffffffffu); }const float MAX_ITERATIONS = 64.; const float PI2 = 6.28318530718; const float EPSILON = 0.0001; const float stepFactor = 0.0098;vec4 godRays(vec2 st, float decay) { vec3 color = vec3(0); float offset = (0.25 + min(1., 0.5000)) * stepFactor; vec2 pos = vec2(0.4765719467956469, 0.3851269649334945) - mix(vec2(0), (vec2(1. - uMousePos.x, 1. - uMousePos.y) - 0.5), 0.0000); float weight = 1.0; float bnoz = randFibo(st) * 0.5000; float distanceInfo = 0.0; vec2 marchPos = st;for (float i = 0.0; i < MAX_ITERATIONS; i += 4.0) { for (float j = 0.0; j < 4.0; j++) { float bno = randFibo(st + vec2(i/MAX_ITERATIONS + j/4.0)) * 0.5000; vec2 offbno = vec2(cos(bno) - 0.5, sin(bno) - 0.5); float x = min(0.999, (i + j) * offset) + bnoz * 0.02; float y = min(0.999, (i + j)); marchPos = st * (1.0 - x) + vec2(x * 0.5) + (pos - 0.5) * x + offbno * 0.02 * 0.2500 * x; color += texture(uTexture, marchPos).rgb * weight; distanceInfo += y * weight; weight *= decay; if(weight < 0.01) break; } } return vec4(color / MAX_ITERATIONS, distance(st, marchPos)); }vec4 getGodRays(vec2 uv) { if(0.5000 == 0.) { return vec4(0); } vec4 rays = godRays(uv, 0.972); rays.rgb *= vec3(1, 1, 1); vec4 color; color.rgb = rays.rgb; color.a = rays.a; return color; }vec4 getColor(vec2 uv) { return getGodRays(uv); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); if(1 == 2) { fragColor = color;} else { fragColor = color; } }","#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture; uniform sampler2D uBlueNoise;uniform vec2 uResolution;const float MAX_ITERATIONS = 64.; const float PI2 = 6.28318530718; const float EPSILON = 0.0001; const float stepFactor = 0.0098;float luma(vec4 color) { return dot(color.rgb, vec3(0.299, 0.587, 0.114)); }float getBlueNoiseOffset(vec2 st) { ivec2 texSize = ivec2(512, 512); vec4 blueNoise = texelFetch(uBlueNoise, ivec2(fract(st * (uResolution)/vec2(texSize) * vec2(texSize.x/texSize.y, 1.0)) * vec2(texSize)) % texSize, 0); return mod((blueNoise.r - 0.5) * PI2, PI2); }vec4 composite(vec2 uv) { vec4 godrays = texture(uTexture, uv); float distanceInfo = godrays.a; float luminance = luma(godrays); float blueNoise = getBlueNoiseOffset(uv) - 0.5; vec2 circNoise = vec2(cos(blueNoise), sin(blueNoise)); float brightnessScale = (1. - (luminance + 0.25)); vec2 offset = circNoise * 0.05 * pow(brightnessScale, 3.) * distanceInfo * 2.; vec4 color = texture(uTexture, uv + offset); vec4 bg = texture(uBgTexture, uv);color.rgb = bg.rgb + (color.rgb * 2.9 * 0.5000 + blueNoise * 0.001); color.a = bg.a + color.r; return color; }vec4 getColor(vec2 uv) { return composite(uv); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); if(2 == 2) { fragColor = color;} else { fragColor = color; } }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false,"passes":[{"prop":"pass","value":1,"downSample":0.5},{"prop":"pass","value":2,"includeBg":true}],"texture":{"src":"https://assets.unicorn.studio/media/blue_noise_med.png","sampler":"uBlueNoise"}},"id":"effect14"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"bloom","usesPingPong":false,"texture":false,"parentLayer":"cf58334b-7b55-4307-a9a3-3c08257498f7","animating":false,"mouseMomentum":0,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;out vec4 fragColor;float luma(vec4 color) { return dot(color.rgb, vec3(0.299, 0.587, 0.114)); }vec4 thresholdPass(vec4 color) { color.rgb = pow(color.rgb, vec3(1.0/2.2)); color.rgb = 1.2 * (color.rgb - 0.5) + 0.5; vec4 bloom = color * smoothstep(0.8200 - 0.1, 0.8200, luma(color)); return vec4(bloom.rgb, color.a); }vec4 getColor(vec4 color) { return thresholdPass(color); }void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); fragColor = getColor(color); }","#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uResolution;out vec4 fragColor;float getExponentialWeight(int index) { switch(index) { case 0: return 1.0000000000; case 1: return 0.7165313106; case 2: return 0.5134171190; case 3: return 0.3678794412; case 4: return 0.2636050919; case 5: return 0.1888756057; case 6: return 0.1353352832; case 7: return 0.0969670595; case 8: return 0.0694877157; default: return 0.0; } }vec4 blur(vec2 uv, bool vertical, float radius, bool diamond) { vec4 color = vec4(0.0); float total_weight = 0.0; float aspectRatio = uResolution.x/uResolution.y;vec2 dir; if (diamond) { dir = vertical ? vec2(1, 1) : vec2(1, -1); } else { dir = vertical ? vec2(0, 1) : vec2(1, 0); } dir *= vec2(0.0000, 1. - 0.0000); dir.x /= aspectRatio; vec4 center = texture(uTexture, uv); float center_weight = getExponentialWeight(0); color += center * center_weight; total_weight += center_weight;radius *= 0.0100; for (int i = 1; i <= 8; i++) { float weight = getExponentialWeight(i); float offset = mix(0.015, 0.025, radius) * float(i)/8.; vec4 sample1 = texture(uTexture, uv + offset * dir); vec4 sample2 = texture(uTexture, uv - offset * dir); color += (sample1 + sample2) * weight; total_weight += 2.0 * weight; }return color / total_weight; }vec4 blurPass(vec2 uv, bool vertical, float radius, float intensity, bool diamond) { return blur(uv, vertical, radius, diamond); }vec4 getColor(vec4 color) { return blurPass(vTextureCoord, false, 40., 1.25, true); }void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); fragColor = getColor(color); }","#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture;uniform vec2 uResolution;out vec4 fragColor;float luma(vec4 color) { return dot(color.rgb, vec3(0.299, 0.587, 0.114)); }float getExponentialWeight(int index) { switch(index) { case 0: return 1.0000000000; case 1: return 0.7165313106; case 2: return 0.5134171190; case 3: return 0.3678794412; case 4: return 0.2636050919; case 5: return 0.1888756057; case 6: return 0.1353352832; case 7: return 0.0969670595; case 8: return 0.0694877157; default: return 0.0; } }vec4 blur(vec2 uv, bool vertical, float radius, bool diamond) { vec4 color = vec4(0.0); float total_weight = 0.0; float aspectRatio = uResolution.x/uResolution.y;vec2 dir; if (diamond) { dir = vertical ? vec2(1, 1) : vec2(1, -1); } else { dir = vertical ? vec2(0, 1) : vec2(1, 0); } dir *= vec2(0.0000, 1. - 0.0000); dir.x /= aspectRatio; vec4 center = texture(uTexture, uv); float center_weight = getExponentialWeight(0); color += center * center_weight; total_weight += center_weight;radius *= 0.0100; for (int i = 1; i <= 8; i++) { float weight = getExponentialWeight(i); float offset = mix(0.015, 0.025, radius) * float(i)/8.; vec4 sample1 = texture(uTexture, uv + offset * dir); vec4 sample2 = texture(uTexture, uv - offset * dir); color += (sample1 + sample2) * weight; total_weight += 2.0 * weight; }return color / total_weight; }vec4 thresholdPass(vec4 color) { color.rgb = pow(color.rgb, vec3(1.0/2.2)); color.rgb = 1.2 * (color.rgb - 0.5) + 0.5; vec4 bloom = color * smoothstep(0.8200 - 0.1, 0.8200, luma(color)); return vec4(bloom.rgb, color.a); }vec4 blurCombinePass(vec2 uv, bool vertical, float radius, float intensity, bool diamond) { vec4 blurred = blur(uv, vertical, radius, diamond); return (thresholdPass(texture(uBgTexture, uv)) * 0.5 + blurred * intensity); }vec4 getColor(vec4 color) { return blurCombinePass(vTextureCoord, true, 40., 1.25, true); }void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); fragColor = getColor(color); }","#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uResolution;out vec4 fragColor;float getExponentialWeight(int index) { switch(index) { case 0: return 1.0000000000; case 1: return 0.7165313106; case 2: return 0.5134171190; case 3: return 0.3678794412; case 4: return 0.2636050919; case 5: return 0.1888756057; case 6: return 0.1353352832; case 7: return 0.0969670595; case 8: return 0.0694877157; default: return 0.0; } }vec4 blur(vec2 uv, bool vertical, float radius, bool diamond) { vec4 color = vec4(0.0); float total_weight = 0.0; float aspectRatio = uResolution.x/uResolution.y;vec2 dir; if (diamond) { dir = vertical ? vec2(1, 1) : vec2(1, -1); } else { dir = vertical ? vec2(0, 1) : vec2(1, 0); } dir *= vec2(0.0000, 1. - 0.0000); dir.x /= aspectRatio; vec4 center = texture(uTexture, uv); float center_weight = getExponentialWeight(0); color += center * center_weight; total_weight += center_weight;radius *= 0.0100; for (int i = 1; i <= 8; i++) { float weight = getExponentialWeight(i); float offset = mix(0.015, 0.025, radius) * float(i)/8.; vec4 sample1 = texture(uTexture, uv + offset * dir); vec4 sample2 = texture(uTexture, uv - offset * dir); color += (sample1 + sample2) * weight; total_weight += 2.0 * weight; }return color / total_weight; }vec4 blurPass(vec2 uv, bool vertical, float radius, float intensity, bool diamond) { return blur(uv, vertical, radius, diamond); }vec4 getColor(vec4 color) { return blurPass(vTextureCoord, false, 15., 1.1, true); }void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); fragColor = getColor(color); }","#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture;uniform vec2 uResolution;out vec4 fragColor;float luma(vec4 color) { return dot(color.rgb, vec3(0.299, 0.587, 0.114)); }float getExponentialWeight(int index) { switch(index) { case 0: return 1.0000000000; case 1: return 0.7165313106; case 2: return 0.5134171190; case 3: return 0.3678794412; case 4: return 0.2636050919; case 5: return 0.1888756057; case 6: return 0.1353352832; case 7: return 0.0969670595; case 8: return 0.0694877157; default: return 0.0; } }vec4 blur(vec2 uv, bool vertical, float radius, bool diamond) { vec4 color = vec4(0.0); float total_weight = 0.0; float aspectRatio = uResolution.x/uResolution.y;vec2 dir; if (diamond) { dir = vertical ? vec2(1, 1) : vec2(1, -1); } else { dir = vertical ? vec2(0, 1) : vec2(1, 0); } dir *= vec2(0.0000, 1. - 0.0000); dir.x /= aspectRatio; vec4 center = texture(uTexture, uv); float center_weight = getExponentialWeight(0); color += center * center_weight; total_weight += center_weight;radius *= 0.0100; for (int i = 1; i <= 8; i++) { float weight = getExponentialWeight(i); float offset = mix(0.015, 0.025, radius) * float(i)/8.; vec4 sample1 = texture(uTexture, uv + offset * dir); vec4 sample2 = texture(uTexture, uv - offset * dir); color += (sample1 + sample2) * weight; total_weight += 2.0 * weight; }return color / total_weight; }vec4 thresholdPass(vec4 color) { color.rgb = pow(color.rgb, vec3(1.0/2.2)); color.rgb = 1.2 * (color.rgb - 0.5) + 0.5; vec4 bloom = color * smoothstep(0.8200 - 0.1, 0.8200, luma(color)); return vec4(bloom.rgb, color.a); }vec4 blurCombinePass(vec2 uv, bool vertical, float radius, float intensity, bool diamond) { vec4 blurred = blur(uv, vertical, radius, diamond); return (thresholdPass(texture(uBgTexture, uv)) * 0.5 + blurred * intensity); }vec4 getColor(vec4 color) { return blurCombinePass(vTextureCoord, true, 15., 1.1, true); }void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); fragColor = getColor(color); }","#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uResolution;out vec4 fragColor;float getExponentialWeight(int index) { switch(index) { case 0: return 1.0000000000; case 1: return 0.7165313106; case 2: return 0.5134171190; case 3: return 0.3678794412; case 4: return 0.2636050919; case 5: return 0.1888756057; case 6: return 0.1353352832; case 7: return 0.0969670595; case 8: return 0.0694877157; default: return 0.0; } }vec4 blur(vec2 uv, bool vertical, float radius, bool diamond) { vec4 color = vec4(0.0); float total_weight = 0.0; float aspectRatio = uResolution.x/uResolution.y;vec2 dir; if (diamond) { dir = vertical ? vec2(1, 1) : vec2(1, -1); } else { dir = vertical ? vec2(0, 1) : vec2(1, 0); } dir *= vec2(0.0000, 1. - 0.0000); dir.x /= aspectRatio; vec4 center = texture(uTexture, uv); float center_weight = getExponentialWeight(0); color += center * center_weight; total_weight += center_weight;radius *= 0.0100; for (int i = 1; i <= 8; i++) { float weight = getExponentialWeight(i); float offset = mix(0.015, 0.025, radius) * float(i)/8.; vec4 sample1 = texture(uTexture, uv + offset * dir); vec4 sample2 = texture(uTexture, uv - offset * dir); color += (sample1 + sample2) * weight; total_weight += 2.0 * weight; }return color / total_weight; }vec4 blurPass(vec2 uv, bool vertical, float radius, float intensity, bool diamond) { return blur(uv, vertical, radius, diamond); }vec4 getColor(vec4 color) { return blurPass(vTextureCoord, false, 7.5, 1., false); }void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); fragColor = getColor(color); }","#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uResolution;out vec4 fragColor;float getExponentialWeight(int index) { switch(index) { case 0: return 1.0000000000; case 1: return 0.7165313106; case 2: return 0.5134171190; case 3: return 0.3678794412; case 4: return 0.2636050919; case 5: return 0.1888756057; case 6: return 0.1353352832; case 7: return 0.0969670595; case 8: return 0.0694877157; default: return 0.0; } }vec4 blur(vec2 uv, bool vertical, float radius, bool diamond) { vec4 color = vec4(0.0); float total_weight = 0.0; float aspectRatio = uResolution.x/uResolution.y;vec2 dir; if (diamond) { dir = vertical ? vec2(1, 1) : vec2(1, -1); } else { dir = vertical ? vec2(0, 1) : vec2(1, 0); } dir *= vec2(0.0000, 1. - 0.0000); dir.x /= aspectRatio; vec4 center = texture(uTexture, uv); float center_weight = getExponentialWeight(0); color += center * center_weight; total_weight += center_weight;radius *= 0.0100; for (int i = 1; i <= 8; i++) { float weight = getExponentialWeight(i); float offset = mix(0.015, 0.025, radius) * float(i)/8.; vec4 sample1 = texture(uTexture, uv + offset * dir); vec4 sample2 = texture(uTexture, uv - offset * dir); color += (sample1 + sample2) * weight; total_weight += 2.0 * weight; }return color / total_weight; }vec4 blurPass(vec2 uv, bool vertical, float radius, float intensity, bool diamond) { return blur(uv, vertical, radius, diamond); }vec4 getColor(vec4 color) { return blurPass(vTextureCoord, true, 7.5, 1., false); }void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); fragColor = getColor(color); }","#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture;uvec2 pcg2d(uvec2 v) { v = v * 1664525u + 1013904223u; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; v ^= v >> 16; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; return v; }float randFibo(vec2 p) { uvec2 v = floatBitsToUint(p); v = pcg2d(v); uint r = v.x ^ v.y; return float(r) / float(0xffffffffu); }out vec4 fragColor;float luma(vec4 color) { return dot(color.rgb, vec3(0.299, 0.587, 0.114)); }vec4 finalPass(vec4 bloomColor) { float dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0; bloomColor.rgb *= vec3(0.0784313725490196, 0.9098039215686274, 0.5215686274509804); bloomColor.rgb += dither; bloomColor.a = luma(bloomColor); vec4 sceneColor = texture(uBgTexture, vTextureCoord); vec4 finalColor = mix(sceneColor, sceneColor + bloomColor, 0.6100 * 1.75); return finalColor; }vec4 getColor(vec4 color) { return finalPass(color); }void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); fragColor = getColor(color); }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"downSample":0.5,"depth":false,"uniforms":{},"isBackground":false,"passes":[{"prop":"pass","value":1,"downSample":0.25},{"prop":"pass","value":2,"downSample":0.25,"includeBg":true},{"prop":"pass","value":3,"downSample":0.25},{"prop":"pass","value":4,"downSample":0.25,"includeBg":true},{"prop":"pass","value":5,"downSample":0.5},{"prop":"pass","value":6,"downSample":0.5,"includeBg":true},{"prop":"pass","value":7,"downSample":1,"includeBg":true}]},"id":"effect15"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"sphere","usesPingPong":false,"radius":1,"amount":0.22,"dispersion":1,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"parentLayer":"b7552748-e750-4446-9fa5-ab54d4a580f5","animating":false,"isMask":0,"states":{"appear":[{"local":{"pendingChanges":{},"changeDebouncer":null,"dragSession":null},"type":"appear","id":"792c7bac-d8b0-40da-b266-9732d124bbaa","prop":"radius","transition":{"ease":"easeInOutQuart","duration":3000,"delay":500},"complete":false,"progress":0,"value":0,"endValue":30.37,"initialized":false,"breakpoints":[],"loop":"none","loopDelay":0,"uniformData":{"type":"1f","name":"uRadius"}},{"local":{"pendingChanges":{},"changeDebouncer":null,"dragSession":null},"type":"appear","id":"18fa5024-01bd-404e-bc10-c918d2969071","prop":"amount","transition":{"duration":1000,"delay":0,"ease":"easeInOutQuart"},"complete":false,"progress":0,"value":0.28,"endValue":0.28,"initialized":false,"breakpoints":[],"loop":"none","loopDelay":0,"uniformData":{"type":"1f","name":"uAmount"}},{"local":{"pendingChanges":{},"changeDebouncer":null,"dragSession":null},"type":"appear","id":"4ac7a60b-1d73-4183-9e97-340cf351e477","prop":"dispersion","transition":{"ease":"easeInOutQuart","duration":2000,"delay":1500},"complete":false,"progress":0,"value":1,"endValue":0,"initialized":false,"breakpoints":[],"loop":"none","loopDelay":0,"uniformData":{"type":"1f","name":"uDispersion"}}],"scroll":[],"hover":[]},"compiledFragmentShaders":["#version 300 es\nprecision highp float; in vec3 vVertexPosition; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform float uAmount; uniform float uDispersion; uniform float uRadius; uniform vec2 uMousePos; uniform vec2 uResolution;const float STEPS = 16.0; const float PI = 3.1415926;vec3 chromaticAbberation(vec2 st, float angle, float amount, float blend) { float aspectRatio = uResolution.x/uResolution.y; float rotation = angle * 360.0 * PI / 180.0; vec2 aberrated = amount * vec2(0.1 * sin(rotation) * aspectRatio, 0.1 * cos(rotation)); aberrated *= distance(st, vec2(0.5)) * 2.0; vec4 red = vec4(0); vec4 blue = vec4(0); vec4 green = vec4(0); float invSteps = 1.0 / STEPS; float invStepsHalf = invSteps * 0.5; for(float i = 1.0; i <= STEPS; i++) { vec2 offset = aberrated * (i * invSteps); red += texture(uTexture, st - offset) * invSteps; blue += texture(uTexture, st + offset) * invSteps; }for (float i = 0.0; i <= STEPS; i++) { vec2 offset = aberrated * ((i * invSteps) - 0.5); green += texture(uTexture, st + offset) * invSteps; } return vec3(red.r, green.g, blue.b); }vec2 sphericalTransformation( float u, float v, float uCenter, float vCenter, float lensRadius, float tau) { float aspectRatio = uResolution.x/uResolution.y; u -= uCenter; v -= vCenter;float s = sqrt(u * u + v * v); if (s > lensRadius) return vec2(u + uCenter, v + vCenter);float z = sqrt(lensRadius * lensRadius - s * s);float uAlpha = (1.0 - (1.0 / tau)) * asin(u / lensRadius); float vAlpha = (1.0 - (1.0 / tau)) * asin(v / lensRadius);u = uCenter + z * sin(uAlpha); v = vCenter + z * sin(vAlpha);return vec2(u/aspectRatio, v); }float circularIn(float t) { return 1.0 - sqrt(1.0 - t * t); }vec2 fisheyeTransformation( float u, float v, float uCenter, float vCenter, float lensRadius, float distortionScale ) { float aspectRatio = uResolution.x / uResolution.y;vec2 dir = vec2(u - uCenter, v - vCenter);dir.x /= lensRadius; dir.y /= lensRadius;float dist = length(dir) * 0.15;if (dist < 1.0) { float theta = atan(dir.y, dir.x);float r = dist * 2.0 * PI; float z = sqrt(1.0 - r * r) + 0.25; float rDist = atan(r, z) / PI; float newDist = mix(dist, rDist, 5.);dir.x = newDist * cos(theta); dir.y = newDist * sin(theta); }dir.x *= lensRadius; dir.y *= lensRadius;return mix(vec2(u/aspectRatio, v), vec2(uCenter/aspectRatio, vCenter) + dir, uAmount); }vec2 discTransformation( float u, float v, float uCenter, float vCenter, float lensRadius, float distortionScale) { float aspectRatio = uResolution.x/uResolution.y; u -= uCenter; v -= vCenter;float s = sqrt(u * u + v * v); if (s > lensRadius) return vec2(u + uCenter, v + vCenter); float r = sqrt(u * u + v * v) / lensRadius; if(r == 0.0) return vec2(uCenter, vCenter);r = pow(r, distortionScale); float theta = atan(r); float rad = theta / r;u = rad * u + uCenter; v = rad * v + vCenter;return vec2(u/aspectRatio, v); }out vec4 fragColor; void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); float aspectRatio = uResolution.x/uResolution.y; uv.x = uv.x * aspectRatio; vec2 sphereCoords = uv; vec2 pos = vec2(0.49093107617896015, 0.11789600967351876) + mix(vec2(0), (uMousePos-0.5), 0.0000); pos.x *= aspectRatio;float radius = uRadius * uResolution.x/max(uResolution.x, uResolution.y);if(0 == 0) { sphereCoords = sphericalTransformation( mix(sphereCoords.x, 1.-sphereCoords.x, 0.0000), mix(sphereCoords.y, 1.-sphereCoords.y, 0.0000), mix(pos.x, 1.-pos.x, 0.0000), mix(pos.y, 1.-pos.y, 0.0000), radius/2., 1. + uAmount * 9. ); } else if(0 == 1) { sphereCoords = discTransformation( mix(sphereCoords.x, 1.-sphereCoords.x, 0.0000), mix(sphereCoords.y, 1.-sphereCoords.y, 0.0000), mix(pos.x, 1.-pos.x, 0.0000), mix(pos.y, 1.-pos.y, 0.0000), radius/2., 1. + uAmount * 9. ); } else if(0 == 2) { sphereCoords = fisheyeTransformation( mix(sphereCoords.x, 1.-sphereCoords.x, 0.0000), mix(sphereCoords.y, 1.-sphereCoords.y, 0.0000), mix(pos.x, 1.-pos.x, 0.0000), mix(pos.y, 1.-pos.y, 0.0000), radius/2., 1. + uAmount * 9. ); }vec2 scaledCoords = (sphereCoords - 0.5) + 0.5; vec4 sphere = texture(uTexture, clamp(scaledCoords, 0.0, 1.0)); float distFromPos = distance(uv, pos); float edgeSmooth = 0.001; float insideSphere = 1.0 - smoothstep(radius/2.0 - edgeSmooth, radius/2.0, distFromPos); float insideSphereAlpha = 1.0 - smoothstep(radius/2.0 + 0.002 - edgeSmooth, radius/2.0 + 0.002, distFromPos); sphere.rgb = chromaticAbberation(scaledCoords, atan(scaledCoords.y, scaledCoords.x), distFromPos * uDispersion, 1.0); color = mix(color, sphere, insideSphere); color.rgb += vec3((0.5000-0.5)*2.) * mix(0., circularIn(smoothstep(0., radius, distFromPos)), insideSphere); if(0 == 1) { color.a = insideSphereAlpha; color.rgb = mix(vec3(0), color.rgb, insideSphereAlpha); } fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect16"}],"options":{"name":"DootLord Meme 2025","fps":60,"dpi":1.5,"scale":1,"includeLogo":false,"isProduction":false},"version":"1.4.32","id":"iTNb060BLNCQz8hCUyyb"}
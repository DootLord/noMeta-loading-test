{"history":[{"breakpoints":[],"visible":true,"aspectRatio":1,"layerType":"effect","type":"gradient","speed":0.25,"trackMouse":0,"mouseMomentum":0,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform vec2 uMousePos; vec3 getColor(int index) { switch(index) { case 0: return vec3(0, 0, 0); case 1: return vec3(0, 0, 0); case 2: return vec3(0, 0, 0); case 3: return vec3(0, 0, 0); case 4: return vec3(0, 0, 0); case 5: return vec3(0, 0, 0); case 6: return vec3(0, 0, 0); case 7: return vec3(0, 0, 0); case 8: return vec3(0, 0, 0); case 9: return vec3(0, 0, 0); case 10: return vec3(0, 0, 0); case 11: return vec3(0, 0, 0); case 12: return vec3(0, 0, 0); case 13: return vec3(0, 0, 0); case 14: return vec3(0, 0, 0); case 15: return vec3(0, 0, 0); default: return vec3(0.0); } }const float PI = 3.14159265;vec2 rotate(vec2 coord, float angle) { float s = sin(angle); float c = cos(angle); return vec2( coord.x * c - coord.y * s, coord.x * s + coord.y * c ); }out vec4 fragColor;vec3 getColor(vec2 uv) {return vec3(0, 0, 0); }void main() { vec2 uv = vTextureCoord; vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.00); uv -= pos; uv /= (0.50*2.); uv = rotate(uv, (0.00 - 0.5) * 2. * PI); vec4 color = vec4(getColor(uv), 1); fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"],"data":{"depth":false,"uniforms":{}}},{"breakpoints":[],"visible":true,"locked":false,"aspectRatio":8.714285714285714,"layerName":"","isElement":true,"opacity":1,"effects":["71bb708a-ecd8-48d4-8919-1175e974b5e0","7a55e45c-6061-49ef-a501-c6b0a931022a"],"displace":0,"trackMouse":0,"anchorPoint":"center","mouseMomentum":0,"blendMode":"NORMAL","bgDisplace":0,"mask":0,"maskBackground":{"type":"Vec3","_x":0,"_y":0,"_z":0},"maskAlpha":0,"maskDepth":0,"dispersion":0,"axisTilt":0,"states":{"appear":[],"scroll":[],"hover":[]},"translateX":-30,"translateY":239,"layerType":"text","justCreated":false,"isSafari":false,"width":0.8856231828039098,"widthMode":"relative","height":135.97101116869652,"heightMode":"fixed","left":0.5080893691797328,"leftMode":"relative","top":0.5892051034445693,"topMode":"relative","rotation":0,"trackMouseMove":0,"fontSize":0.054000000000000006,"lineHeight":1.7485983946591628,"letterSpacing":-0.028301483783805183,"fontFamily":"Departure Mono","fontStyle":"regular","fontWeight":"400","textAlign":"center","textContent":"Coming Soon!","fill":["#9D9D9D"],"gradientAngle":0,"gradientType":"linear","fontSizeMode":"relative","fontCSS":{"family":"Departure Mono","src":"https://assets.unicorn.studio/fonts/studio_picks/DepartureMono/DepartureMono-Regular.woff"},"compiledFragmentShaders":["#version 300 es\nprecision mediump float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uBgTexture; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform int uSampleBg;out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.00);uv = uv - pos;vec4 color = texture(uTexture, uv); vec4 background = vec4(0);if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); }color = mix(background, color / max(color.a, 0.0001), color.a * 1.00);fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25; mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"uniforms":{}},"windowWidth":1440},{"breakpoints":[],"visible":true,"locked":false,"aspectRatio":8.714285714285714,"layerName":"noMeta","isElement":true,"opacity":1,"effects":["f0f3eacb-1a0b-4a79-8d43-6a05ae91d447","abfe2e26-b1a1-468f-9738-910d5e27000a"],"displace":0,"trackMouse":0,"anchorPoint":"center","mouseMomentum":0,"blendMode":"NORMAL","bgDisplace":0,"mask":0,"maskBackground":{"type":"Vec3","_x":0,"_y":0,"_z":0},"maskAlpha":0,"maskDepth":0,"dispersion":0,"axisTilt":0,"states":{"appear":[],"scroll":[],"hover":[]},"translateX":-30,"translateY":239,"layerType":"text","justCreated":false,"isSafari":false,"width":0.8804591605141793,"widthMode":"relative","height":245.08235294117648,"heightMode":"fixed","left":0.4988658247690425,"leftMode":"relative","top":0.4503203629981541,"topMode":"relative","rotation":0,"trackMouseMove":0,"fontSize":0.124,"lineHeight":1.3725490196078431,"letterSpacing":-0.028301483783805183,"fontFamily":"Departure Mono","fontStyle":"regular","fontWeight":"400","textAlign":"center","textContent":"noMeta","fill":["#9D9D9D"],"gradientAngle":0,"gradientType":"linear","fontSizeMode":"relative","fontCSS":{"family":"Departure Mono","src":"https://assets.unicorn.studio/fonts/studio_picks/DepartureMono/DepartureMono-Regular.woff"},"compiledFragmentShaders":["#version 300 es\nprecision mediump float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uBgTexture; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform int uSampleBg;out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.00);uv = uv - pos;vec4 color = texture(uTexture, uv); vec4 background = vec4(0);if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); }color = mix(background, color / max(color.a, 0.0001), color.a * 1.00);fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25; mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"uniforms":{}},"windowWidth":1440},{"breakpoints":[],"visible":true,"aspectRatio":1,"layerType":"effect","type":"beam","speed":0.25,"trackMouse":0,"mouseMomentum":0,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime;uniform vec2 uMousePos; vec3 blend (int blendMode, vec3 src, vec3 dst) { return src * dst; }vec3 Tonemap_tanh(vec3 x) { x = clamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }out vec4 fragColor;const float PI = 3.14159265359; const float TWO_PI = 2.0 * PI;vec3 drawLine(vec2 uv, vec2 center, float scale, float angle) { float radAngle = -angle * TWO_PI; float phase = fract(uTime * 0.01 + 0.50) * (3. * max(1., scale)) - (1.5 * max(1., scale));vec2 direction = vec2(cos(radAngle), sin(radAngle));vec2 centerToPoint = uv - center;float projection = dot(centerToPoint, direction);float distToLine = length(centerToPoint - projection * direction);float lineRadius = 0.38 * 0.25; float brightness = lineRadius / (1. - smoothstep(0.4, 0., distToLine + 0.02));float glowRadius = scale; float glow = smoothstep(glowRadius, 0.0, abs(projection - phase));return brightness * (1.-distToLine)*(1.-distToLine) * vec3(0, 0.7450980392156863, 0.9725490196078431) * glow; }vec3 getBeam(vec2 uv) { vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.00); return drawLine(uv, pos, 0.29, -0.01); }void main() { vec2 uv = vTextureCoord; vec4 bg = texture(uTexture, uv);vec3 beam = getBeam(uv); float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0;vec3 blended = blend(3, Tonemap_tanh(beam), bg.rgb); vec3 result = mix(bg.rgb, blended, 0.38); result += dither;fragColor = vec4(result, bg.a); }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{}}},{"breakpoints":[],"visible":true,"aspectRatio":1,"layerType":"effect","type":"replicate","speed":0.27,"parentLayer":"71bb708a-ecd8-48d4-8919-1175e974b5e0","animating":true,"mouseMomentum":0,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform float uTime;uniform vec2 uResolution;out vec4 fragColor;void main() { vec2 uv = vTextureCoord; float rotation = (-0.25 * 2. * 3.141592653); float aspectRatio = uResolution.x/uResolution.y; vec2 aberrated = vec2(0); vec4 col = vec4(0); float repeatSpacing = 1.80 * 0.35 * mix(1., aspectRatio, 0.5); float time = (uTime * 0.025) / (repeatSpacing + 0.001);for(float i = 0.; i < 16.00; i++){ float offset = repeatSpacing * (i - 16.00/2. + fract(time)); aberrated = vec2(offset * sin(rotation), offset * cos(rotation)); col += texture(uTexture, uv + aberrated) * (1. - col.a); } fragColor = col;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{}}},{"breakpoints":[],"visible":true,"aspectRatio":1,"layerType":"effect","type":"voronoi","speed":1,"trackMouse":1,"mouseMomentum":0,"parentLayer":"7a55e45c-6061-49ef-a501-c6b0a931022a","animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t < 0.5 ? (1.0 - sqrt(1.0 - 4.0 * t * t)) / 2.0 : (sqrt(-((2.0 * t) - 3.0) * ((2.0 * t) - 1.0)) + 1.0) / 2.0; } vec2 random2( vec2 p ) { return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453); }const float PI = 3.14159265359; mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); } out vec4 fragColor; void main() { vec2 uv = vTextureCoord; float aspectRatio = uResolution.x/uResolution.y;vec2 skew = mix(vec2(1), vec2(1, 0), 0.50);vec2 st = (uv - vec2(0.5, 0.5)) * vec2(aspectRatio, 1.) * 50. * 0.89; st = st * rot(0.75 * 2. * PI) * skew; vec2 i_st = floor(st); vec2 f_st = fract(st);float m_dist = 15.; vec2 m_point; vec2 d;for (int j=-1; j<=1; j++ ) { for (int i=-1; i<=1; i++ ) { vec2 neighbor = vec2(float(i),float(j)); vec2 point = random2(i_st + neighbor);point = 0.5 + 0.5 * sin(5. + uTime * 0.2 + 6.2831*point); vec2 diff = neighbor + point - f_st; float dist = length(diff);if( dist < m_dist ) { m_dist = dist; m_point = point; d = diff; } } }vec2 offset = (m_point * 0.2 * 0.91 * 2.) - (0.91 * 0.2);vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 1.00); vec2 pos = vec2(0.5, 0.5); float dist = ease(15, max(0.,1.-distance(uv * vec2(aspectRatio, 1), mPos * vec2(aspectRatio, 1)) * 4. * (1. - 0.10)));vec4 color = texture(uTexture, uv + offset * dist); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{}}},{"breakpoints":[],"visible":true,"aspectRatio":1,"layerType":"effect","type":"retro_screen","speed":0.25,"trackMouse":0,"mouseMomentum":0,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec2 vTextureCoord; uniform sampler2D uTexture; uniform vec2 uResolution; uniform float uTime;out vec4 fragColor;vec3 styleOne(vec2 curvedUV) { float size = max(3.0 / 1080.0, 0.02 * (1.0 - 0.59));vec2 aspectRatio = vec2(uResolution.x / uResolution.y, 1.0); float maxSide = max(uResolution.x, uResolution.y);float maxDimension = max(aspectRatio.x, 1.0);vec2 cellSize = vec2(size) / maxDimension;cellSize = floor(cellSize * maxSide) / maxSide;cellSize /= aspectRatio * 0.75;vec2 staggeredUV = curvedUV; if (mod(floor(curvedUV.x / cellSize.x), 2.0) > 0.5) { staggeredUV.y += 0.5 * cellSize.y; }vec2 cellCoords = floor(staggeredUV / cellSize) * cellSize;vec2 unstaggerOffset = vec2(0.0); if (mod(floor(curvedUV.x / cellSize.x), 2.0) > 0.5) { unstaggerOffset.y = -0.5 * cellSize.y; }vec2 sampleCoord = cellCoords + 0.5 * cellSize + unstaggerOffset; vec4 texColor = texture(uTexture, sampleCoord);vec2 staggeredCellPos = mod(staggeredUV, cellSize) / cellSize;float segmentWidth = 0.5; vec3 finalColor = vec3(0.0);float distCoord = staggeredCellPos.x;float distRed = abs(distCoord - segmentWidth * 0.5); float distGreen = abs(distCoord - segmentWidth * 1.); float distBlue = abs(distCoord - segmentWidth * 1.5);distRed = min(distRed, 1.0 - distRed); distGreen = min(distGreen, 1.0 - distGreen); distBlue = min(distBlue, 1.0 - distBlue);float softness = 0.5 * segmentWidth; float redFactor = smoothstep(softness, 0.0, distRed * 1.05); float greenFactor = smoothstep(softness, 0.0, distGreen * 1.1); float blueFactor = smoothstep(softness, 0.0, distBlue * 0.9);vec3 blurColor = vec3(0.0); float blurFactor = 1.0 / 9.0; for (int dx = -1; dx <= 1; dx++) { for (int dy = -1; dy <= 1; dy++) { vec2 offset = vec2(dx, dy) * cellSize * 0.36; blurColor += texture(uTexture, sampleCoord + offset).rgb * blurFactor; } } finalColor.r = redFactor * blurColor.r * (3. * 0.87); finalColor.g = greenFactor * blurColor.g * (3. * 0.87); finalColor.b = blueFactor * blurColor.b * (3. * 0.87);float edgeWidth = 0.05; vec2 edgeDistance = abs(staggeredCellPos - 0.5); float edgeFactor = smoothstep(0.45 - edgeWidth, 0.5, max(edgeDistance.x, edgeDistance.y)); edgeFactor = ((1.0 - edgeFactor) + 0.2); finalColor = finalColor * edgeFactor; finalColor = floor(finalColor * 64.00) / 64.00;float flicker = 1.0+0.03*cos(sampleCoord.x/6e1 + uTime*2e1); finalColor *= mix(1., flicker, 0.86);return finalColor; }void main() { vec3 finalColor;vec4 color = texture(uTexture, vTextureCoord);if(color.a == 0.) { fragColor = vec4(0); return; }finalColor = styleOne(vTextureCoord);fragColor = vec4(finalColor, texture(uTexture, vTextureCoord).a); }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{}}},{"breakpoints":[],"visible":true,"aspectRatio":1,"layerType":"effect","type":"replicate","speed":0.08,"parentLayer":"f0f3eacb-1a0b-4a79-8d43-6a05ae91d447","animating":true,"mouseMomentum":0,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform float uTime;uniform vec2 uResolution;out vec4 fragColor;void main() { vec2 uv = vTextureCoord; float rotation = (-0.25 * 2. * 3.141592653); float aspectRatio = uResolution.x/uResolution.y; vec2 aberrated = vec2(0); vec4 col = vec4(0); float repeatSpacing = 1.84 * 0.35 * mix(1., aspectRatio, 0.5); float time = (uTime * 0.025) / (repeatSpacing + 0.001);for(float i = 0.; i < 16.00; i++){ float offset = repeatSpacing * (i - 16.00/2. + fract(time)); aberrated = vec2(offset * sin(rotation), offset * cos(rotation)); col += texture(uTexture, uv + aberrated) * (1. - col.a); } fragColor = col;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{}}},{"breakpoints":[],"visible":true,"aspectRatio":1,"layerType":"effect","type":"voronoi","speed":1,"trackMouse":1,"mouseMomentum":0,"parentLayer":"abfe2e26-b1a1-468f-9738-910d5e27000a","animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t < 0.5 ? (1.0 - sqrt(1.0 - 4.0 * t * t)) / 2.0 : (sqrt(-((2.0 * t) - 3.0) * ((2.0 * t) - 1.0)) + 1.0) / 2.0; } vec2 random2( vec2 p ) { return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453); }const float PI = 3.14159265359; mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); } out vec4 fragColor; void main() { vec2 uv = vTextureCoord; float aspectRatio = uResolution.x/uResolution.y;vec2 skew = mix(vec2(1), vec2(1, 0), 0.50);vec2 st = (uv - vec2(0.5, 0.5)) * vec2(aspectRatio, 1.) * 50. * 0.89; st = st * rot(0.75 * 2. * PI) * skew; vec2 i_st = floor(st); vec2 f_st = fract(st);float m_dist = 15.; vec2 m_point; vec2 d;for (int j=-1; j<=1; j++ ) { for (int i=-1; i<=1; i++ ) { vec2 neighbor = vec2(float(i),float(j)); vec2 point = random2(i_st + neighbor);point = 0.5 + 0.5 * sin(5. + uTime * 0.2 + 6.2831*point); vec2 diff = neighbor + point - f_st; float dist = length(diff);if( dist < m_dist ) { m_dist = dist; m_point = point; d = diff; } } }vec2 offset = (m_point * 0.2 * 0.91 * 2.) - (0.91 * 0.2);vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 1.00); vec2 pos = vec2(0.5, 0.5); float dist = ease(15, max(0.,1.-distance(uv * vec2(aspectRatio, 1), mPos * vec2(aspectRatio, 1)) * 4. * (1. - 0.10)));vec4 color = texture(uTexture, uv + offset * dist); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{}}},{"breakpoints":[],"visible":true,"aspectRatio":1,"layerType":"effect","type":"bloom","animating":false,"mouseMomentum":0,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;out vec4 fragColor;float luma(vec4 color) { return dot(color.rgb, vec3(0.299, 0.587, 0.114)); }vec4 thresholdPass(vec4 color) { float gamma = 2.2; color.rgb = pow(color.rgb, vec3(1.0/gamma)); color.rgb = 1.2 * (color.rgb - 0.5) + 0.5; vec4 bloom = color * smoothstep(0.50 - 0.1, 0.50, luma(color)); return vec4(bloom.rgb, color.a); }vec4 getColor(vec4 color) { return thresholdPass(color); }void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); fragColor = getColor(color); }","#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture;uniform vec2 uResolution;out vec4 fragColor;float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }float luma(vec4 color) { return dot(color.rgb, vec3(0.299, 0.587, 0.114)); }float getExponentialWeight(int index) { switch(index) { case 0: return 1.0000000000; case 1: return 0.7165313106; case 2: return 0.5134171190; case 3: return 0.3678794412; case 4: return 0.2636050919; case 5: return 0.1888756057; case 6: return 0.1353352832; case 7: return 0.0969670595; case 8: return 0.0694877157; default: return 0.0; } }vec4 blur(vec2 uv, bool vertical, float radius, bool diamond) { vec4 color = vec4(0.0); float total_weight = 0.0; float aspectRatio = uResolution.x/uResolution.y;vec2 dir; if (diamond) { dir = vertical ? vec2(1, 1) : vec2(1, -1); } else { dir = vertical ? vec2(0, 1) : vec2(1, 0); } dir *= vec2(0.50, 1. - 0.50); dir.x /= aspectRatio; vec4 center = texture(uTexture, uv); float center_weight = getExponentialWeight(0); color += center * center_weight; total_weight += center_weight;radius *= 0.50; for (int i = 1; i <= 8; i++) { float weight = getExponentialWeight(i); float offset = mix(0.015, 0.025, radius) * float(i)/8.; vec4 sample1 = texture(uTexture, uv + offset * dir); vec4 sample2 = texture(uTexture, uv - offset * dir); color += (sample1 + sample2) * weight; total_weight += 2.0 * weight; }return color / total_weight; }vec4 thresholdPass(vec4 color) { float gamma = 2.2; color.rgb = pow(color.rgb, vec3(1.0/gamma)); color.rgb = 1.2 * (color.rgb - 0.5) + 0.5; vec4 bloom = color * smoothstep(0.50 - 0.1, 0.50, luma(color)); return vec4(bloom.rgb, color.a); }vec4 blurPass(vec2 uv, bool vertical, float radius, float intensity, bool diamond) { float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0; vec4 blurred = blur(uv, vertical, radius, diamond); blurred.rgb += dither; if(vertical && 1 != 6) { return (thresholdPass(texture(uBgTexture, uv)) * 0.5 + blurred * intensity); } else { return blurred; } }vec4 getColor(vec4 color) { return blurPass(vTextureCoord, false, 40., 1.25, true); }void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); fragColor = getColor(color); }","#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture;uniform vec2 uResolution;out vec4 fragColor;float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }float luma(vec4 color) { return dot(color.rgb, vec3(0.299, 0.587, 0.114)); }float getExponentialWeight(int index) { switch(index) { case 0: return 1.0000000000; case 1: return 0.7165313106; case 2: return 0.5134171190; case 3: return 0.3678794412; case 4: return 0.2636050919; case 5: return 0.1888756057; case 6: return 0.1353352832; case 7: return 0.0969670595; case 8: return 0.0694877157; default: return 0.0; } }vec4 blur(vec2 uv, bool vertical, float radius, bool diamond) { vec4 color = vec4(0.0); float total_weight = 0.0; float aspectRatio = uResolution.x/uResolution.y;vec2 dir; if (diamond) { dir = vertical ? vec2(1, 1) : vec2(1, -1); } else { dir = vertical ? vec2(0, 1) : vec2(1, 0); } dir *= vec2(0.50, 1. - 0.50); dir.x /= aspectRatio; vec4 center = texture(uTexture, uv); float center_weight = getExponentialWeight(0); color += center * center_weight; total_weight += center_weight;radius *= 0.50; for (int i = 1; i <= 8; i++) { float weight = getExponentialWeight(i); float offset = mix(0.015, 0.025, radius) * float(i)/8.; vec4 sample1 = texture(uTexture, uv + offset * dir); vec4 sample2 = texture(uTexture, uv - offset * dir); color += (sample1 + sample2) * weight; total_weight += 2.0 * weight; }return color / total_weight; }vec4 thresholdPass(vec4 color) { float gamma = 2.2; color.rgb = pow(color.rgb, vec3(1.0/gamma)); color.rgb = 1.2 * (color.rgb - 0.5) + 0.5; vec4 bloom = color * smoothstep(0.50 - 0.1, 0.50, luma(color)); return vec4(bloom.rgb, color.a); }vec4 blurPass(vec2 uv, bool vertical, float radius, float intensity, bool diamond) { float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0; vec4 blurred = blur(uv, vertical, radius, diamond); blurred.rgb += dither; if(vertical && 2 != 6) { return (thresholdPass(texture(uBgTexture, uv)) * 0.5 + blurred * intensity); } else { return blurred; } }vec4 getColor(vec4 color) { return blurPass(vTextureCoord, true, 40., 1.25, true); }void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); fragColor = getColor(color); }","#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture;uniform vec2 uResolution;out vec4 fragColor;float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }float luma(vec4 color) { return dot(color.rgb, vec3(0.299, 0.587, 0.114)); }float getExponentialWeight(int index) { switch(index) { case 0: return 1.0000000000; case 1: return 0.7165313106; case 2: return 0.5134171190; case 3: return 0.3678794412; case 4: return 0.2636050919; case 5: return 0.1888756057; case 6: return 0.1353352832; case 7: return 0.0969670595; case 8: return 0.0694877157; default: return 0.0; } }vec4 blur(vec2 uv, bool vertical, float radius, bool diamond) { vec4 color = vec4(0.0); float total_weight = 0.0; float aspectRatio = uResolution.x/uResolution.y;vec2 dir; if (diamond) { dir = vertical ? vec2(1, 1) : vec2(1, -1); } else { dir = vertical ? vec2(0, 1) : vec2(1, 0); } dir *= vec2(0.50, 1. - 0.50); dir.x /= aspectRatio; vec4 center = texture(uTexture, uv); float center_weight = getExponentialWeight(0); color += center * center_weight; total_weight += center_weight;radius *= 0.50; for (int i = 1; i <= 8; i++) { float weight = getExponentialWeight(i); float offset = mix(0.015, 0.025, radius) * float(i)/8.; vec4 sample1 = texture(uTexture, uv + offset * dir); vec4 sample2 = texture(uTexture, uv - offset * dir); color += (sample1 + sample2) * weight; total_weight += 2.0 * weight; }return color / total_weight; }vec4 thresholdPass(vec4 color) { float gamma = 2.2; color.rgb = pow(color.rgb, vec3(1.0/gamma)); color.rgb = 1.2 * (color.rgb - 0.5) + 0.5; vec4 bloom = color * smoothstep(0.50 - 0.1, 0.50, luma(color)); return vec4(bloom.rgb, color.a); }vec4 blurPass(vec2 uv, bool vertical, float radius, float intensity, bool diamond) { float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0; vec4 blurred = blur(uv, vertical, radius, diamond); blurred.rgb += dither; if(vertical && 3 != 6) { return (thresholdPass(texture(uBgTexture, uv)) * 0.5 + blurred * intensity); } else { return blurred; } }vec4 getColor(vec4 color) { return blurPass(vTextureCoord, false, 15., 1.1, false); }void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); fragColor = getColor(color); }","#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture;uniform vec2 uResolution;out vec4 fragColor;float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }float luma(vec4 color) { return dot(color.rgb, vec3(0.299, 0.587, 0.114)); }float getExponentialWeight(int index) { switch(index) { case 0: return 1.0000000000; case 1: return 0.7165313106; case 2: return 0.5134171190; case 3: return 0.3678794412; case 4: return 0.2636050919; case 5: return 0.1888756057; case 6: return 0.1353352832; case 7: return 0.0969670595; case 8: return 0.0694877157; default: return 0.0; } }vec4 blur(vec2 uv, bool vertical, float radius, bool diamond) { vec4 color = vec4(0.0); float total_weight = 0.0; float aspectRatio = uResolution.x/uResolution.y;vec2 dir; if (diamond) { dir = vertical ? vec2(1, 1) : vec2(1, -1); } else { dir = vertical ? vec2(0, 1) : vec2(1, 0); } dir *= vec2(0.50, 1. - 0.50); dir.x /= aspectRatio; vec4 center = texture(uTexture, uv); float center_weight = getExponentialWeight(0); color += center * center_weight; total_weight += center_weight;radius *= 0.50; for (int i = 1; i <= 8; i++) { float weight = getExponentialWeight(i); float offset = mix(0.015, 0.025, radius) * float(i)/8.; vec4 sample1 = texture(uTexture, uv + offset * dir); vec4 sample2 = texture(uTexture, uv - offset * dir); color += (sample1 + sample2) * weight; total_weight += 2.0 * weight; }return color / total_weight; }vec4 thresholdPass(vec4 color) { float gamma = 2.2; color.rgb = pow(color.rgb, vec3(1.0/gamma)); color.rgb = 1.2 * (color.rgb - 0.5) + 0.5; vec4 bloom = color * smoothstep(0.50 - 0.1, 0.50, luma(color)); return vec4(bloom.rgb, color.a); }vec4 blurPass(vec2 uv, bool vertical, float radius, float intensity, bool diamond) { float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0; vec4 blurred = blur(uv, vertical, radius, diamond); blurred.rgb += dither; if(vertical && 4 != 6) { return (thresholdPass(texture(uBgTexture, uv)) * 0.5 + blurred * intensity); } else { return blurred; } }vec4 getColor(vec4 color) { return blurPass(vTextureCoord, true, 15., 1.1, false); }void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); fragColor = getColor(color); }","#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture;uniform vec2 uResolution;out vec4 fragColor;float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }float luma(vec4 color) { return dot(color.rgb, vec3(0.299, 0.587, 0.114)); }float getExponentialWeight(int index) { switch(index) { case 0: return 1.0000000000; case 1: return 0.7165313106; case 2: return 0.5134171190; case 3: return 0.3678794412; case 4: return 0.2636050919; case 5: return 0.1888756057; case 6: return 0.1353352832; case 7: return 0.0969670595; case 8: return 0.0694877157; default: return 0.0; } }vec4 blur(vec2 uv, bool vertical, float radius, bool diamond) { vec4 color = vec4(0.0); float total_weight = 0.0; float aspectRatio = uResolution.x/uResolution.y;vec2 dir; if (diamond) { dir = vertical ? vec2(1, 1) : vec2(1, -1); } else { dir = vertical ? vec2(0, 1) : vec2(1, 0); } dir *= vec2(0.50, 1. - 0.50); dir.x /= aspectRatio; vec4 center = texture(uTexture, uv); float center_weight = getExponentialWeight(0); color += center * center_weight; total_weight += center_weight;radius *= 0.50; for (int i = 1; i <= 8; i++) { float weight = getExponentialWeight(i); float offset = mix(0.015, 0.025, radius) * float(i)/8.; vec4 sample1 = texture(uTexture, uv + offset * dir); vec4 sample2 = texture(uTexture, uv - offset * dir); color += (sample1 + sample2) * weight; total_weight += 2.0 * weight; }return color / total_weight; }vec4 thresholdPass(vec4 color) { float gamma = 2.2; color.rgb = pow(color.rgb, vec3(1.0/gamma)); color.rgb = 1.2 * (color.rgb - 0.5) + 0.5; vec4 bloom = color * smoothstep(0.50 - 0.1, 0.50, luma(color)); return vec4(bloom.rgb, color.a); }vec4 blurPass(vec2 uv, bool vertical, float radius, float intensity, bool diamond) { float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0; vec4 blurred = blur(uv, vertical, radius, diamond); blurred.rgb += dither; if(vertical && 5 != 6) { return (thresholdPass(texture(uBgTexture, uv)) * 0.5 + blurred * intensity); } else { return blurred; } }vec4 getColor(vec4 color) { return blurPass(vTextureCoord, false, 7.5, 1., true); }void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); fragColor = getColor(color); }","#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture;uniform vec2 uResolution;out vec4 fragColor;float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }float luma(vec4 color) { return dot(color.rgb, vec3(0.299, 0.587, 0.114)); }float getExponentialWeight(int index) { switch(index) { case 0: return 1.0000000000; case 1: return 0.7165313106; case 2: return 0.5134171190; case 3: return 0.3678794412; case 4: return 0.2636050919; case 5: return 0.1888756057; case 6: return 0.1353352832; case 7: return 0.0969670595; case 8: return 0.0694877157; default: return 0.0; } }vec4 blur(vec2 uv, bool vertical, float radius, bool diamond) { vec4 color = vec4(0.0); float total_weight = 0.0; float aspectRatio = uResolution.x/uResolution.y;vec2 dir; if (diamond) { dir = vertical ? vec2(1, 1) : vec2(1, -1); } else { dir = vertical ? vec2(0, 1) : vec2(1, 0); } dir *= vec2(0.50, 1. - 0.50); dir.x /= aspectRatio; vec4 center = texture(uTexture, uv); float center_weight = getExponentialWeight(0); color += center * center_weight; total_weight += center_weight;radius *= 0.50; for (int i = 1; i <= 8; i++) { float weight = getExponentialWeight(i); float offset = mix(0.015, 0.025, radius) * float(i)/8.; vec4 sample1 = texture(uTexture, uv + offset * dir); vec4 sample2 = texture(uTexture, uv - offset * dir); color += (sample1 + sample2) * weight; total_weight += 2.0 * weight; }return color / total_weight; }vec4 thresholdPass(vec4 color) { float gamma = 2.2; color.rgb = pow(color.rgb, vec3(1.0/gamma)); color.rgb = 1.2 * (color.rgb - 0.5) + 0.5; vec4 bloom = color * smoothstep(0.50 - 0.1, 0.50, luma(color)); return vec4(bloom.rgb, color.a); }vec4 blurPass(vec2 uv, bool vertical, float radius, float intensity, bool diamond) { float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0; vec4 blurred = blur(uv, vertical, radius, diamond); blurred.rgb += dither; if(vertical && 6 != 6) { return (thresholdPass(texture(uBgTexture, uv)) * 0.5 + blurred * intensity); } else { return blurred; } }vec4 getColor(vec4 color) { return blurPass(vTextureCoord, true, 7.5, 1., true); }void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); fragColor = getColor(color); }","#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture;out vec4 fragColor;float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }vec4 finalPass(vec4 bloomColor) { float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0; bloomColor.rgb *= vec3(1, 1, 1); bloomColor.rgb += dither; vec4 sceneColor = texture(uBgTexture, vTextureCoord); vec4 finalColor = mix(sceneColor, sceneColor + bloomColor, 0.50 * 1.75); return finalColor; }vec4 getColor(vec4 color) { return finalPass(color); }void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); fragColor = getColor(color); }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"passes":[{"prop":"pass","value":1,"downSample":0.5},{"prop":"pass","value":2,"downSample":0.5},{"prop":"pass","value":3,"downSample":0.25},{"prop":"pass","value":4,"downSample":0.25},{"prop":"pass","value":5,"downSample":0.5},{"prop":"pass","value":6,"downSample":0.5},{"prop":"pass","value":7,"includeBg":true}]}},{"breakpoints":[],"visible":true,"aspectRatio":1,"layerType":"effect","type":"vignette","trackMouse":0,"mouseMomentum":0,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float; in vec3 vVertexPosition; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution; vec3 blend (int blendMode, vec3 src, vec3 dst) { return src; }out vec4 fragColor; void main() { vec2 uv = vTextureCoord;vec4 color = texture(uTexture, uv); float colorAlpha = color.a; float luma = dot(color.rgb, vec3(0.299, 0.587, 0.114)); float displacement = (luma - 0.5) * 0.00 * 0.5; vec2 aspectRatio = vec2(uResolution.x/uResolution.y, 1.) * vec2(0.50, 1.-0.50); float scaledRadius = 0.88 * 0.5;float adjustedRadius = scaledRadius + 1.00 * scaledRadius; float innerEdge = scaledRadius - 1.00 * scaledRadius * 0.5; float outerEdge = scaledRadius + 1.00 * scaledRadius * 0.5;vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.00);float radius = length(uv * aspectRatio - pos * aspectRatio); float falloff = smoothstep(innerEdge + displacement, outerEdge + displacement, radius);if(0 > 0) { vec3 blended = blend(0, vec3(0, 0, 0), color.rgb); color.rgb = mix(color.rgb, blended, falloff * 1.00); } else { color.rgb = mix(color.rgb, mix(color.rgb, vec3(0, 0, 0), 1.00), falloff); }color.a = mix((1. - falloff), 1., 1.00); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{}}},{"breakpoints":[],"visible":true,"aspectRatio":1,"layerType":"effect","type":"texturize","speed":0.11,"animating":true,"mouseMomentum":0,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform float uTime;float random (in float x) { return fract(sin(x)*43758.5453); }float random2(vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; float sizeX = 0.50 * 0.2 * random(floor(uTime * 0.5) * 2. + 0.001); float sizeY = 0.50 * 0.2 * random(floor(uTime * 0.5) * 2. + 1.001); float floorY = floor(uv.y/sizeY) + 0.0001; float floorX = floor(uv.x/sizeX) + 0.0001; float phase = 0.00 * 0.01; float chromab = 0.00 * 0.75; float offset = 0.; vec2 blockSize = vec2(50.0, 50.0) * (1.0 - 0.50); vec2 blockUV = floor(uv * blockSize) / blockSize; float blockNoise = mix( 1., step(0.8, random2(vec2(random(floor(uTime * 0.5) * 2. + 0.001), random2(blockUV)))), 0.08 );float offsetX = 0.44 * 0.5 * blockNoise; float offsetY = 0.00 * 0.5 * blockNoise;float glitchModX = max(0.001, sign(random(sin(floorY + offset + phase)) - 0.5 - (1. - 0.08*2.)/2.)); float glitchModY = max(0.001, sign(random(cos(floorX + offset + phase)) - 0.5 - (1. - 0.08*2.)/2.));float offX = ( (random(floorY + offset * glitchModX + phase)) * offsetX - offsetX/2. )/5.; float offY = ( (random(floorX + offset * glitchModY + phase)) * offsetY - offsetY/2. )/5.;offX = min(max(offX, -1.), 1.); offY = min(max(offY, -1.), 1.);uv.x = mix(uv.x, uv.x + offX * 2., glitchModX); uv.y = mix(uv.y, uv.y + offY * 2., glitchModY);float waveFreq = 30.0; float waveAmp = 0.005 * 0.00;float rogue = smoothstep(0., 2., sin((uv.y + 0.00) * waveFreq * (1. - 0.50) * 2. + uTime * 0.05) - 0.5) * 0.2 * 0.00; uv.x += sin(uv.y * waveFreq + uTime) * waveAmp + rogue; uv.y += sin(uv.x * waveFreq + uTime) * waveAmp; float waveX = sin(uv.y * waveFreq + uTime) * waveAmp + rogue * chromab * 0.2;uv = clamp(uv, vec2(0.001), vec2(1.0));vec4 color = texture(uTexture, uv);color.r = texture(uTexture, vec2( clamp(uv.x + (glitchModX * -offX * chromab - waveX), 0.01, 1.0), clamp(uv.y + (glitchModX * -offY * chromab), 0.01, 1.0) )).r; color.b = texture(uTexture, vec2( clamp(uv.x + (glitchModX * offX * chromab + waveX), 0.01, 1.0), clamp(uv.y + (glitchModX * offY * chromab), 0.01, 1.0) )).b; fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{}}}],"options":{"name":"Particleizer","fps":60,"dpi":1.5,"scale":1,"includeLogo":false,"isProduction":false},"version":"1.4.0","id":"pySWFR0GXeDHEr0ik1St"}